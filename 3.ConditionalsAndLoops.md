## Conditionals in Java: Making Decisions in Code

Conditionals are fundamental building blocks in programming that allow your code to make decisions and execute different paths based on specific conditions. They introduce logic and control flow into your programs, enabling them to respond dynamically to various inputs and situations. In Java, you have several powerful tools for implementing conditional logic: `if` statements, `switch` statements, and the ternary operator. Let's delve into each of these in detail.

### 1. `if` Statements: Branching Based on Truth

`if` statements are the most basic form of conditional control in Java. They allow you to execute a block of code only if a certain condition is true.

#### 1.1 Simple `if` Statement

The simplest form of an `if` statement executes a block of code if a given boolean condition evaluates to `true`.

*   **Syntax of `if` statement:**

```java
if (booleanCondition) {
    // Code to be executed if booleanCondition is true
}
```

*   **Boolean condition in `if`:**

    The `booleanCondition` inside the parentheses must be an expression that evaluates to either `true` or `false`. This can be:
    *   A boolean variable: `boolean isValid = true; if (isValid) { ... }`
    *   A comparison using relational operators: `if (age >= 18) { ... }`
    *   A method call that returns a boolean: `if (isFileReady()) { ... }`
    *   A combination of conditions using logical operators: `if (age > 13 && age < 19) { ... }`

*   **Block of code execution based on condition:**

    The code enclosed within the curly braces `{}` following the `if` condition is called the `if` block. This block of code is executed *only* if the `booleanCondition` evaluates to `true`. If the condition is `false`, the `if` block is skipped entirely, and the program continues execution from the line following the `if` block.

    **Example:**

    ```java
    int temperature = 25;
    if (temperature > 20) {
        System.out.println("It's a warm day!");
    }
    System.out.println("Program continues...");
    ```

    **Output:**

    ```
    It's a warm day!
    Program continues...
    ```

    If `temperature` was 15, the output would be:

    ```
    Program continues...
    ```

#### 1.2 `if-else` Statement

The `if-else` statement extends the `if` statement by providing an alternative block of code to execute when the condition is `false`.

*   **Syntax of `if-else` statement:**

```java
if (booleanCondition) {
    // Code to be executed if booleanCondition is true (if block)
} else {
    // Code to be executed if booleanCondition is false (else block)
}
```

*   **Execution of `if` block when condition is true:**

    If `booleanCondition` is `true`, the code inside the `if` block (the first block of code within curly braces) is executed.

*   **Execution of `else` block when condition is false:**

    If `booleanCondition` is `false`, the code inside the `else` block (the second block of code within curly braces) is executed.  Crucially, *one and only one* of these blocks will be executed in an `if-else` statement.

    **Example:**

    ```java
    int age = 15;
    if (age >= 18) {
        System.out.println("You are eligible to vote.");
    } else {
        System.out.println("You are not yet eligible to vote.");
    }
    ```

    **Output:**

    ```
    You are not yet eligible to vote.
    ```

    If `age` was 20, the output would be:

    ```
    You are eligible to vote.
    ```

#### 1.3 `if-else-if` Ladder (or `if-else if-else`)

The `if-else-if` ladder allows you to check multiple conditions sequentially. It's used when you have more than two possible paths of execution based on different conditions.

*   **Syntax of `if-else-if` ladder:**

```java
if (condition1) {
    // Code to be executed if condition1 is true
} else if (condition2) {
    // Code to be executed if condition1 is false AND condition2 is true
} else if (condition3) {
    // Code to be executed if condition1 and condition2 are false AND condition3 is true
} // ... more else-if blocks can be added
else { // Optional else block
    // Code to be executed if none of the above conditions are true
}
```

*   **Multiple conditions checking sequentially:**

    Conditions are checked in the order they appear, from top to bottom.

*   **Execution of the first true condition's block:**

    As soon as a condition evaluates to `true`, the code block associated with that `if` or `else if` is executed, and the rest of the ladder is skipped.  Even if subsequent conditions might also be true, they are not checked.

*   **Optional `else` block at the end for default case:**

    The final `else` block is optional. If included, it acts as a default case. If none of the preceding `if` or `else if` conditions are `true`, the code in the `else` block will be executed. If there's no final `else` block and none of the conditions are true, then no code block within the ladder will be executed.

    **Example:**

    ```java
    int score = 75;
    if (score >= 90) {
        System.out.println("Grade: A");
    } else if (score >= 80) {
        System.out.println("Grade: B");
    } else if (score >= 70) {
        System.out.println("Grade: C");
    } else if (score >= 60) {
        System.out.println("Grade: D");
    } else {
        System.out.println("Grade: F");
    }
    ```

    **Output:**

    ```
    Grade: C
    ```

    In this example, even though `score >= 60` is also true, the condition `score >= 70` is checked and found true first, so the "Grade: C" block is executed, and the rest of the `if-else-if` ladder is skipped.

#### 1.4 Nested `if` Statements

Nested `if` statements involve placing an `if` statement (or `if-else`, `if-else-if`) inside another `if` block (or `else` or `else if` block). This allows for more complex, multi-level conditional logic.

*   **`if` statement inside another `if` block:**

```java
if (condition1) {
    // Outer if block
    if (condition2) {
        // Inner if block - executed only if condition1 AND condition2 are true
    }
}
```

*   **`if-else` inside another `if` block:**

```java
if (condition1) {
    // Outer if block
    if (condition2) {
        // Inner if block - executed if condition1 and condition2 are true
    } else {
        // Inner else block - executed if condition1 is true and condition2 is false
    }
}
```

*   **Complexity and readability considerations of nesting:**

    While nesting `if` statements is possible, deep nesting can quickly make code difficult to read, understand, and maintain.  Excessive nesting can lead to "spaghetti code" and increase the likelihood of errors.  For complex conditions, consider:
    *   **Simplifying conditions:** Re-evaluate your boolean expressions to see if they can be made simpler.
    *   **Using logical operators:** Combine multiple conditions into a single, more complex condition using `&&` (AND), `||` (OR).
    *   **Early returns or guard clauses:** In functions, using `return` statements early in the function to handle certain conditions can reduce nesting.
    *   **Refactoring into separate methods:** Break down complex conditional logic into smaller, more manageable methods.

    **Example of Nested `if`:**

    ```java
    int age = 25;
    boolean hasLicense = true;

    if (age >= 18) {
        System.out.println("Age condition met.");
        if (hasLicense) {
            System.out.println("You are eligible to drive.");
        } else {
            System.out.println("You are old enough but need a license to drive.");
        }
    } else {
        System.out.println("You are not old enough to drive.");
    }
    ```

    **Output:**

    ```
    Age condition met.
    You are eligible to drive.
    ```

#### 1.5 Scope of `if` blocks

Scope refers to the region of a program where a variable is accessible. Understanding variable scope within `if` blocks is crucial to avoid errors.

*   **Variables declared inside `if` blocks:**

    Variables declared *inside* an `if` block (or any block of code enclosed in `{}`) have *block scope*. This means they are only accessible within that block.

*   **Visibility of variables outside `if` blocks:**

    Variables declared inside an `if` block are *not* visible or accessible outside of that `if` block.  Trying to use a variable declared inside an `if` block outside of it will result in a compile-time error.

    **Example demonstrating scope:**

    ```java
    if (true) {
        int localVar = 10; // localVar is declared inside the if block
        System.out.println("Inside if block: " + localVar); // Accessible here
    }
    // System.out.println("Outside if block: " + localVar); // Error! localVar is out of scope here
    int globalVar = 20; // Declared outside any block
    if (true) {
        System.out.println("Inside if block, globalVar: " + globalVar); // Accessible here
    }
    System.out.println("Outside if block, globalVar: " + globalVar); // Accessible here
    ```

    **Output:**

    ```
    Inside if block: 10
    Inside if block, globalVar: 20
    Outside if block, globalVar: 20
    ```

    Variables declared outside any blocks (like `globalVar` in the example) have a wider scope and can be accessed from within `if` blocks.

### 2. `switch` Statements: Multi-Way Branching Based on Value

`switch` statements provide an efficient way to handle multi-way branching when you need to choose one block of code to execute from several options based on the value of a single expression. `switch` is often more readable and efficient than long `if-else-if` ladders when dealing with a fixed set of discrete values.

#### 2.1 `switch` Statement Syntax

*   **Expression in `switch` (data types: `int`, `char`, `enum`, `String` (from Java 7+))**

    The `switch` statement starts with a keyword `switch` followed by an *expression* in parentheses. The data type of this expression must be one of the following:
    *   `int` and `Integer` (and `byte`, `short`)
    *   `char` and `Character`
    *   `enum` types
    *   `String` (from Java 7 onwards)

*   **`case` labels and values:**

    Inside the `switch` block, you have `case` labels. Each `case` label is followed by a constant value and a colon `:`. The value after `case` must be compatible with the data type of the `switch` expression. When the value of the `switch` expression matches the value after a `case` label, the code block following that `case` label starts to execute.

*   **`default` case (optional):**

    The `default` case is optional. If provided, it is executed when the value of the `switch` expression does not match any of the `case` values.  It's good practice to include a `default` case to handle unexpected or unhandled values.

*   **`break` statement usage:**

    The `break` statement is crucial in traditional `switch` statements. When a `break` statement is encountered, it immediately exits the `switch` block. Without `break`, execution "falls through" to the next `case` block, which is often not the intended behavior.

    **Syntax of `switch` statement:**

    ```java
    switch (expression) {
        case value1:
            // Code to be executed if expression == value1
            break; // Important to exit switch
        case value2:
            // Code to be executed if expression == value2
            break;
        // ... more case labels
        default: // Optional default case
            // Code to be executed if expression doesn't match any case value
            break; // Optional break for default case (but good practice)
    }
    ```

    **Example:**

    ```java
    int dayOfWeek = 3;
    String dayName;

    switch (dayOfWeek) {
        case 1:
            dayName = "Monday";
            break;
        case 2:
            dayName = "Tuesday";
            break;
        case 3:
            dayName = "Wednesday";
            break;
        case 4:
            dayName = "Thursday";
            break;
        case 5:
            dayName = "Friday";
            break;
        case 6:
            dayName = "Saturday";
            break;
        case 7:
            dayName = "Sunday";
            break;
        default:
            dayName = "Invalid day";
            break;
    }
    System.out.println("Day " + dayOfWeek + " is " + dayName);
    ```

    **Output:**

    ```
    Day 3 is Wednesday
    ```

#### 2.2 `case` Labels

*   **Constant expressions as `case` values:**

    The values following `case` labels must be constant expressions. This means they must be values that are known at compile time. You cannot use variables or non-constant expressions as `case` values (except for `enum` constants and `String` literals, which are also effectively constants in this context).

*   **Matching expression value with `case` values:**

    The `switch` statement evaluates the `expression` and then compares its value against each `case` value. The comparison is based on equality (`==`).

*   **Multiple `case` labels for the same code block (fall-through):**

    You can have multiple `case` labels associated with the same block of code. This is achieved by listing `case` labels one after another without a `break` statement in between. This utilizes the "fall-through" behavior, which will be discussed in more detail later.

    **Example with multiple `case` labels:**

    ```java
    int month = 2; // February
    int daysInMonth;

    switch (month) {
        case 1:  // January
        case 3:  // March
        case 5:  // May
        case 7:  // July
        case 8:  // August
        case 10: // October
        case 12: // December
            daysInMonth = 31;
            break;
        case 4:  // April
        case 6:  // June
        case 9:  // September
        case 11: // November
            daysInMonth = 30;
            break;
        case 2:  // February
            daysInMonth = 28; // Ignoring leap year for simplicity
            break;
        default:
            daysInMonth = -1; // Invalid month
            break;
    }
    System.out.println("Days in month " + month + ": " + daysInMonth);
    ```

    **Output:**

    ```
    Days in month 2: 28
    ```

    In this example, cases 1, 3, 5, 7, 8, 10, and 12 all lead to the same code block because there are no `break` statements until `daysInMonth = 31;` is reached.

#### 2.3 `default` Case

*   **Execution when no `case` matches the expression:**

    The `default` case acts as a catch-all. If the `switch` expression's value does not match any of the `case` values, and a `default` case is present, the code block associated with `default` is executed.

*   **Placement of `default` case (typically last):**

    Although not strictly required by syntax, it's conventional and good practice to place the `default` case as the last case in the `switch` statement. This makes the structure clearer and easier to understand.

*   **Optional nature of `default` case:**

    The `default` case is optional. If you omit the `default` case and none of the `case` values match the `switch` expression, then no code block within the `switch` statement is executed. The program simply continues execution from the line after the `switch` block.

#### 2.4 `break` Statement in `switch`

*   **Purpose of `break` to exit `switch`:**

    The primary purpose of the `break` statement within a `switch` case is to terminate the execution of the `switch` statement immediately. When `break` is encountered, the program jumps out of the `switch` block and continues execution from the line following the `switch` statement.

*   **Preventing fall-through with `break`:**

    By placing a `break` statement at the end of each `case` block (and typically after the `default` case), you prevent "fall-through". This ensures that only the code block associated with the matching `case` (or the `default` case) is executed, and no other `case` blocks are accidentally run.

*   **Consequences of omitting `break` (fall-through behavior):**

    If you omit the `break` statement at the end of a `case` block, execution will "fall through" to the next `case` block. This means that the code in the next `case` block will also be executed, even if the `switch` expression's value did not match that `case` value. Fall-through continues until a `break` statement is encountered or the end of the `switch` block is reached.

#### 2.5 Fall-through Behavior

*   **Execution of subsequent `case` blocks if `break` is missing:**

    As explained above, without a `break` statement, execution falls through to the next `case`. This means that after executing the code for a matching `case`, the program will continue executing the code in the subsequent `case` blocks in order, regardless of their `case` values.

*   **Use cases and potential pitfalls of fall-through:**

    Fall-through is sometimes used intentionally when you want multiple `case` values to execute the same or similar code.  The example of days in months earlier demonstrated this for months with 31 days.

    However, fall-through is often a source of errors if not used intentionally.  It's easy to forget to add a `break` statement, leading to unexpected and incorrect program behavior.  Therefore, it's crucial to be deliberate when using fall-through and to comment your code clearly to indicate why fall-through is intended in specific cases.

    **Example demonstrating fall-through (intentional, but can be error-prone if not careful):**

    ```java
    int number = 1;
    switch (number) {
        case 1:
            System.out.println("Case 1");
            // No break here - fall-through intended
        case 2:
            System.out.println("Case 2");
            break;
        case 3:
            System.out.println("Case 3");
            break;
        default:
            System.out.println("Default case");
            break;
    }
    ```

    **Output:**

    ```
    Case 1
    Case 2
    ```

    Because there is no `break` in `case 1`, execution falls through to `case 2`, and "Case 2" is also printed before the `break` in `case 2` terminates the `switch`.

#### 2.6 Enhanced `switch` Statements (Java 12+)

Java 12 introduced enhanced `switch` statements that offer a more concise and less error-prone syntax. These enhancements aim to improve readability and reduce boilerplate code, especially by addressing the fall-through issue.

*   **Arrow `case` labels (`->`)**

    Enhanced `switch` uses arrow labels (`->`) instead of colon labels (`:`) for `case`s.  With arrow labels, you don't need `break` statements to prevent fall-through.

*   **No fall-through by default in arrow `case`**

    The key difference is that with arrow `case` labels, fall-through is *not* automatic.  Only the code to the right of the arrow is executed for a matching `case`, and then the `switch` statement exits.

*   **Concise syntax for single-statement cases**

    For simple cases where you want to execute a single statement, you can write it directly after the arrow without curly braces.

*   **Returning values from `switch` expressions**

    Enhanced `switch` can also be used as an expression that returns a value. This is particularly useful for initializing variables or as part of larger expressions. To return a value, you can use the `yield` keyword (for multi-statement blocks) or simply place the value directly after the arrow (for single expressions).

    **Example of Enhanced `switch`:**

    ```java
    int dayOfWeek = 3;
    String dayName = switch (dayOfWeek) { // switch as an expression
        case 1 -> "Monday";
        case 2 -> "Tuesday";
        case 3 -> "Wednesday";
        case 4 -> "Thursday";
        case 5 -> "Friday";
        case 6 -> "Saturday";
        case 7 -> "Sunday";
        default -> "Invalid day"; // default is still recommended
    };
    System.out.println("Day " + dayOfWeek + " is " + dayName);
    ```

    **Output:**

    ```
    Day 3 is Wednesday
    ```

    **Example with multi-statement cases and `yield`:**

    ```java
    int month = 2;
    int daysInMonth = switch (month) {
        case 1, 3, 5, 7, 8, 10, 12 -> 31; // Multiple cases, single result
        case 4, 6, 9, 11 -> 30;
        case 2 -> { // Multi-statement block for February
            System.out.println("Handling February...");
            yield 28; // Use yield to return a value from a block
        }
        default -> {
            System.out.println("Invalid month number!");
            yield -1;
        }
    };
    System.out.println("Days in month " + month + ": " + daysInMonth);
    ```

    **Output:**

    ```
    Handling February...
    Days in month 2: 28
    ```

    Enhanced `switch` offers a cleaner and more modern approach to multi-way branching, reducing the risks associated with fall-through and allowing for more expressive and concise code.

### 3. Conditional Operator (Ternary Operator)

The ternary operator `(?:)` is a shorthand for simple `if-else` statements. It provides a concise way to choose between two expressions based on a condition.

#### 3.1 Ternary Operator Syntax (`? :`)

*   **Condition, true expression, false expression:**

    The ternary operator has three parts:
    1.  **Condition:** A boolean expression that is evaluated.
    2.  **True Expression:** The expression that is evaluated and returned if the condition is `true`.
    3.  **False Expression:** The expression that is evaluated and returned if the condition is `false`.

    **Syntax:**

    ```java
    condition ? trueExpression : falseExpression
    ```

    The entire ternary expression evaluates to either `trueExpression` or `falseExpression`, depending on the truth value of `condition`.

*   **Concise way to express simple `if-else`:**

    The ternary operator is most effective for simple `if-else` scenarios where you want to choose between two values or perform a simple action based on a condition. It can make code more compact and readable in such cases.

    **Example:**

    ```java
    int age = 15;
    String message = (age >= 18) ? "Eligible to vote" : "Not eligible to vote";
    System.out.println(message);
    ```

    **Output:**

    ```
    Not eligible to vote
    ```

    This ternary operator is equivalent to:

    ```java
    int age = 15;
    String message;
    if (age >= 18) {
        message = "Eligible to vote";
    } else {
        message = "Not eligible to vote";
    }
    System.out.println(message);
    ```

#### 3.2 Using Ternary Operator for Assignment

*   **Assigning values based on condition result:**

    The most common use case for the ternary operator is to assign a value to a variable based on a condition.  The result of the ternary operation is assigned to a variable on the left-hand side of the assignment operator (`=`).

*   **Inline conditional assignment:**

    Ternary operators enable inline conditional assignment, meaning you can perform the conditional logic directly within the assignment statement, making the code more concise.

    **Example of assignment:**

    ```java
    int num1 = 10;
    int num2 = 20;
    int max = (num1 > num2) ? num1 : num2; // Assigns the larger number to max
    System.out.println("Maximum: " + max);
    ```

    **Output:**

    ```
    Maximum: 20
    ```

#### 3.3 Nesting Ternary Operators (with Caution)

*   **Possibility of nesting ternary operators:**

    You can nest ternary operators, meaning you can place one ternary operator inside another, either as the `trueExpression` or the `falseExpression` or both.

*   **Reduced readability in complex nested ternary operations:**

    While nesting is possible, it can quickly lead to code that is very difficult to read and understand. Deeply nested ternary operators become cryptic and can obscure the logic, making maintenance and debugging a nightmare.

*   **Recommendation to use `if-else` for complex conditions:**

    For any conditional logic that is more complex than a simple choice between two values, it's generally strongly recommended to use `if-else` statements instead of nested ternary operators. `if-else` statements are much clearer and easier to follow for complex conditions, even if they are slightly more verbose. Readability and maintainability should be prioritized over extreme conciseness in most situations.

    **Example of nested ternary (avoid if possible for readability):**

    ```java
    int score = 85;
    String grade = (score >= 90) ? "A" : (score >= 80) ? "B" : (score >= 70) ? "C" : "D"; // Hard to read!
    System.out.println("Grade: " + grade);
    ```

    This nested ternary is functionally equivalent to the `if-else-if` ladder for grading, but it's much less readable. The `if-else-if` version is almost always preferable for clarity in such scenarios.

### 4. Boolean Expressions in Conditionals

Conditionals in Java rely heavily on boolean expressions to determine which code paths to execute. Boolean expressions are expressions that evaluate to either `true` or `false`. They are formed using relational and logical operators.

#### 4.1 Relational Operators

Relational operators compare two values and return a boolean result (`true` or `false`) based on the relationship between them.

*   **`==` (Equal to):**

    Checks if two values are equal. Returns `true` if they are equal, `false` otherwise.
    *   Example: `5 == 5` (true), `5 == 6` (false)

*   **`!=` (Not equal to):**

    Checks if two values are not equal. Returns `true` if they are not equal, `false` otherwise.
    *   Example: `5 != 6` (true), `5 != 5` (false)

*   **`>` (Greater than):**

    Checks if the left operand is greater than the right operand. Returns `true` if it is, `false` otherwise.
    *   Example: `10 > 5` (true), `5 > 10` (false)

*   **`<` (Less than):**

    Checks if the left operand is less than the right operand. Returns `true` if it is, `false` otherwise.
    *   Example: `5 < 10` (true), `10 < 5` (false)

*   **`>=` (Greater than or equal to):**

    Checks if the left operand is greater than or equal to the right operand. Returns `true` if it is, `false` otherwise.
    *   Example: `10 >= 10` (true), `10 >= 5` (true), `5 >= 10` (false)

*   **`<=` (Less than or equal to):**

    Checks if the left operand is less than or equal to the right operand. Returns `true` if it is, `false` otherwise.
    *   Example: `5 <= 5` (true), `5 <= 10` (true), `10 <= 5` (false)

*   **Resulting in boolean `true` or `false`:**

    All relational operators result in a boolean value, which can then be used directly in `if` conditions, `switch` cases (indirectly through the `switch` expression), ternary operators, or assigned to boolean variables.

#### 4.2 Logical Operators

Logical operators combine or modify boolean expressions to create more complex conditions.

*   **`&&` (Logical AND):**

    The logical AND operator returns `true` if *both* operands are `true`. Otherwise, it returns `false`.

    *   **Truth table of AND:**

        | Operand 1 | Operand 2 | Operand 1 `&&` Operand 2 |
        | :-------- | :-------- | :------------------------- |
        | `true`    | `true`    | `true`                     |
        | `true`    | `false`   | `false`                    |
        | `false`   | `true`    | `false`                    |
        | `false`   | `false`   | `false`                    |

    *   **Short-circuiting behavior of `&&`:**

        Logical AND exhibits short-circuiting. If the first operand is `false`, the second operand is *not* evaluated. This is because the result of the AND operation will be `false` regardless of the value of the second operand. This short-circuiting can be important for performance and for preventing errors (e.g., avoiding a NullPointerException if the second condition depends on the first condition being true).

        **Example of short-circuiting in `&&`:**

        ```java
        boolean isAdult = false;
        int age = 15;

        if (isAdult && (age > 18)) { // age > 18 will NOT be evaluated because isAdult is false
            System.out.println("Both conditions are true.");
        } else {
            System.out.println("At least one condition is false.");
        }
        ```

        In this case, `age > 18` is never evaluated because `isAdult` is already `false`.

*   **`||` (Logical OR):**

    The logical OR operator returns `true` if *at least one* of the operands is `true`. It returns `false` only if *both* operands are `false`.

    *   **Truth table of OR:**

        | Operand 1 | Operand 2 | Operand 1 `||` Operand 2 |
        | :-------- | :-------- | :------------------------- |
        | `true`    | `true`    | `true`                     |
        | `true`    | `false`   | `true`                     |
        | `false`   | `true`    | `true`                     |
        | `false`   | `false`   | `false`                    |

    *   **Short-circuiting behavior of `||`:**

        Logical OR also exhibits short-circuiting. If the first operand is `true`, the second operand is *not* evaluated. This is because the result of the OR operation will be `true` regardless of the value of the second operand. Similar to `&&`, this can improve performance and prevent errors.

        **Example of short-circuiting in `||`:**

        ```java
        boolean isWeekend = true;
        String day = "Monday";

        if (isWeekend || day.equals("Friday")) { // day.equals("Friday") will NOT be evaluated because isWeekend is true
            System.out.println("It's either the weekend or Friday.");
        } else {
            System.out.println("It's a weekday and not Friday.");
        }
        ```

        Here, `day.equals("Friday")` is not evaluated because `isWeekend` is already `true`.

*   **`!` (Logical NOT):**

    The logical NOT operator is a unary operator (it operates on a single operand). It inverts the boolean value of its operand. If the operand is `true`, `!` makes it `false`, and if it's `false`, `!` makes it `true`.

    *   **Truth table of NOT:**

        | Operand | `!` Operand |
        | :------ | :---------- |
        | `true`  | `false`     |
        | `false` | `true`      |

    *   **Inverting boolean values:**

        The NOT operator is used to reverse the logical meaning of a condition.

        **Example of NOT operator:**

        ```java
        boolean isLoggedIn = false;

        if (!isLoggedIn) { // Equivalent to if (isLoggedIn == false)
            System.out.println("Please log in to continue.");
        } else {
            System.out.println("Welcome!");
        }
        ```

        **Output:**

        ```
        Please log in to continue.
        ```

#### 4.3 Combining Relational and Logical Operators

*   **Complex boolean conditions:**

    You can create complex boolean conditions by combining relational and logical operators. This allows you to express intricate decision-making logic in your code.

*   **Operator precedence (e.g., AND vs OR):**

    Java has operator precedence rules that determine the order in which operators are evaluated in an expression. Logical AND (`&&`) has higher precedence than logical OR (`||`).  Relational operators generally have higher precedence than logical operators.

    *   Example: `a > b && c < d || e == f`  is interpreted as `((a > b) && (c < d)) || (e == f)` because `&&` has higher precedence than `||`.

*   **Use of parentheses for clarity and precedence control:**

    To make complex boolean expressions clearer and to explicitly control the order of evaluation, it's highly recommended to use parentheses `()`. Parentheses have the highest precedence and force the expressions within them to be evaluated first.

    **Example demonstrating operator precedence and parentheses:**

    ```java
    int x = 5, y = 10, z = 15;
    boolean result;

    result = x < y && y < z || x > z; // Without parentheses, relies on precedence
    System.out.println("Result without parentheses: " + result); // Output: true

    result = (x < y && y < z) || (x > z); // With parentheses, clarifies grouping
    System.out.println("Result with parentheses: " + result); // Output: true

    result = x < y && (y < z || x > z); // Changed grouping with parentheses
    System.out.println("Result with different parentheses: " + result); // Output: true
    ```

    While the output might be the same in some cases, using parentheses consistently makes your code easier to read and understand, and prevents potential errors due to misinterpreting operator precedence.

### 5. Best Practices and Considerations for Conditionals

Writing effective and maintainable conditional statements is crucial for creating robust and understandable Java code. Here are some best practices and considerations:

#### 5.1 Readability and Clarity

*   **Writing clear and understandable conditional statements:**

    Prioritize clarity and readability when writing conditional statements.  The goal is for anyone reading your code (including your future self) to quickly grasp the logic and intent.

*   **Avoiding overly complex conditions:**

    Break down complex conditions into simpler, more manageable parts. Long and convoluted boolean expressions are hard to read and debug.

*   **Using meaningful variable names in conditions:**

    Use descriptive variable names that clearly indicate what the variable represents. This makes conditions self-documenting. For example, `isUserLoggedIn` is much clearer than `flag`.

    **Example of improved readability:**

    **Less readable:**

    ```java
    if (x > 10 && y < 20 || !z) { ... }
    ```

    **More readable (assuming context):**

    ```java
    boolean isWithinRange = x > 10 && y < 20;
    boolean isZValid = !z; // Or rename z to something more descriptive
    if (isWithinRange || isZValid) { ... }
    ```

#### 5.2 Avoiding Nested `if` Complexity

*   **Strategies to reduce nesting (e.g., early returns, guard clauses):**

    Deeply nested `if` statements can become very hard to follow. Strategies to reduce nesting include:
    *   **Early Returns (Guard Clauses):** In methods, use `return` statements early to handle error conditions or simple cases, reducing the need for deeper nesting.

        ```java
        public void processData(Data data) {
            if (data == null) { // Guard clause - handles null input early
                System.out.println("Error: Data cannot be null.");
                return; // Exit the method early
            }
            // Now we can assume data is not null, proceed with main logic
            if (data.isValid()) {
                // ... main processing logic ...
            } else {
                System.out.println("Error: Data is invalid.");
            }
        }
        ```

    *   **Combining Conditions:** Use logical operators (`&&`, `||`) to combine conditions and reduce nesting levels.

*   **Improving code structure for better readability:**

    Refactor complex conditional logic into smaller, well-named methods. This breaks down the complexity and makes the code easier to understand and test.

#### 5.3 Choosing between `if-else-if` and `switch`

*   **When `switch` is more suitable (multiple discrete values):**

    Use `switch` statements when you need to check for equality against a fixed set of discrete values of a single variable (or expression). `switch` is generally more efficient and readable than a long `if-else-if` ladder in such cases.

*   **When `if-else-if` is necessary (range checks, complex conditions):**

    Use `if-else-if` ladders when you need to check conditions based on ranges of values, complex boolean expressions, or different variables in each condition. `switch` is not suitable for range checks or conditions that are not based on simple equality.

    **Example of choosing between `switch` and `if-else-if`:**

    **Using `switch` (for discrete values):**

    ```java
    int errorCode = 404;
    String errorMessage;
    switch (errorCode) {
        case 200: errorMessage = "OK"; break;
        case 404: errorMessage = "Not Found"; break;
        case 500: errorMessage = "Internal Server Error"; break;
        default: errorMessage = "Unknown Error"; break;
    }
    ```

    **Using `if-else-if` (for range check):**

    ```java
    int temperature = 15;
    String weatherCondition;
    if (temperature > 30) {
        weatherCondition = "Hot";
    } else if (temperature > 20) {
        weatherCondition = "Warm";
    } else if (temperature > 10) {
        weatherCondition = "Mild";
    } else {
        weatherCondition = "Cold";
    }
    ```

#### 5.4 Code Maintainability

*   **Making conditionals easy to modify and understand in the future:**

    Write conditionals with future maintainability in mind.  Choose clear and straightforward logic, even if it's slightly more verbose than a very concise but cryptic alternative.  Well-structured conditionals are easier to modify and debug as requirements change.

*   **Consistent coding style for conditionals:**

    Follow a consistent coding style for indentation, bracing, and spacing in your conditional statements. Consistency improves readability and reduces the cognitive load when reading and modifying code.  Adhere to established coding conventions for Java (e.g., Google Java Style Guide, Oracle Java Code Conventions).

#### 5.5 Handling Multiple Conditions Effectively

*   **Breaking down complex conditions into smaller, manageable parts:**

    If you have very complex boolean conditions, break them down into smaller, named boolean variables or methods. This makes the overall condition easier to understand and test.

*   **Using helper methods or functions for complex condition logic:**

    For intricate conditional logic, especially if it's reused in multiple places, encapsulate it within helper methods or functions. This promotes code reuse, improves readability, and makes testing easier.

    **Example of using a helper method:**

    ```java
    public boolean isEligibleForDiscount(Customer customer, Product product) {
        return isLoyalCustomer(customer) && isProductOnSale(product);
    }

    private boolean isLoyalCustomer(Customer customer) {
        // ... complex logic to determine if customer is loyal ...
        return customer.getYearsAsCustomer() > 5 && customer.getTotalPurchases() > 1000;
    }

    private boolean isProductOnSale(Product product) {
        // ... logic to check if product is on sale ...
        return product.getDiscountPercentage() > 0;
    }

    // In your main logic:
    if (isEligibleForDiscount(currentCustomer, selectedProduct)) {
        // Apply discount
    }
    ```

By following these best practices, you can write conditional statements in Java that are not only functional but also clear, maintainable, and less prone to errors, contributing to higher quality code.

## Loops in Java (Expanded)

Loops are fundamental control flow structures in programming that allow you to repeatedly execute a block of code as long as a certain condition is met. Java provides several types of loops, each suited for different scenarios.

### Types of Loops

Java offers four main types of loops: `for`, `while`, `do-while`, and the enhanced `for` loop (for-each loop).

#### `for` loop

The `for` loop is typically used when you know in advance how many times you want to execute a block of code. It's excellent for iterating a specific number of times or iterating over a range.

##### Syntax of `for` loop (detailed breakdown: `initialization; condition; increment/decrement`)

The `for` loop syntax is structured into three parts within parentheses, followed by the loop body:

```java
for (initialization; condition; increment/decrement) {
    // Loop body: code to be executed repeatedly
}
```

*   **`initialization`:** This is executed *only once* at the very beginning of the loop, before the first iteration. It's typically used to initialize a loop counter variable.
*   **`condition`:** This is a boolean expression that is evaluated *before each iteration* (including the very first one). If the condition is `true`, the loop body is executed. If it's `false`, the loop terminates, and execution continues after the loop block.
*   **`increment/decrement`:** This is executed *after each iteration* of the loop body. It's commonly used to update the loop counter variable, usually to move towards the condition becoming `false` and eventually terminating the loop.

Let's break down each part further:

##### Initialization Block in `for` loop

The initialization block is where you set up the loop's starting state.

*   **Declaration and initialization of loop counter variable:**
    This is the most common use case. You declare and initialize a variable that will act as your loop counter, often named `i`, `j`, or `k`. The scope of a variable declared here is typically limited to the loop itself (more on scope later).

    ```java
    for (int i = 0; i < 5; i++) { // i is declared and initialized here
        System.out.println("Iteration: " + i);
    }
    // i is not accessible here (out of scope)
    ```

*   **Multiple initializations (comma-separated - less common but valid):**
    You can initialize multiple variables in the initialization block using commas.  While less common for simple loops, it can be useful in specific scenarios, especially when dealing with nested loops or multiple counters.

    ```java
    for (int i = 0, j = 10; i < 5; i++, j--) {
        System.out.println("i: " + i + ", j: " + j);
    }
    ```

*   **Initialization outside the loop scope (pre-existing variables):**
    You can use variables that were declared and initialized *before* the loop. In this case, the initialization part of the `for` loop can be left empty, or just include assignment.

    ```java
    int i = 0; // i is declared and initialized outside
    for (; i < 5; i++) { // Initialization part is empty, but we use pre-existing i
        System.out.println("Iteration: " + i);
    }
    System.out.println("Value of i after loop: " + i); // i is still accessible here
    ```

*   **No initialization part (using pre-initialized variables):**
    If a variable is already initialized before the loop, you can completely omit the initialization part. You must still include the semicolon.

    ```java
    int counter = 5;
    for (; counter > 0; counter--) { // No initialization part
        System.out.println("Counter: " + counter);
    }
    ```

##### Condition in `for` loop

The condition part is a boolean expression that determines whether the loop body will be executed in the current iteration.

*   **Boolean expression evaluation:**
    The condition must evaluate to a boolean value (`true` or `false`).

*   **Relational operators in conditions (`<`, `>`, `<=`, `>=`, `==`, `!=`):**
    These operators are commonly used to compare values and form the boolean condition.

    ```java
    for (int i = 1; i <= 5; i++) { // Using <= operator
        System.out.println(i);
    }

    for (int count = 10; count > 0; count--) { // Using > operator
        System.out.println("Countdown: " + count);
    }
    ```

*   **Logical operators in conditions (`&&`, `||`, `!`):**
    You can combine multiple conditions using logical operators to create more complex conditions.

    ```java
    for (int i = 0; i < 10; i++) {
        if (i % 2 == 0 && i % 3 == 0) { // Using && (AND) operator
            System.out.println(i + " is divisible by both 2 and 3");
        }
    }

    for (int j = 1; j <= 5; j++) {
        if (j < 3 || j > 4) { // Using || (OR) operator
            System.out.println(j + " is less than 3 or greater than 4");
        }
    }

    boolean flag = false;
    for (int k = 0; k < 3; k++) {
        if (!flag) { // Using ! (NOT) operator
            System.out.println("Flag is false in iteration: " + k);
            flag = true; // Change flag after first iteration
        }
    }
    ```

*   **Constant `true` condition (creating infinite loops intentionally):**
    If you set the condition to `true`, the loop will run indefinitely unless a `break` statement is used within the loop body to terminate it. This is how you create intentional infinite loops.

    ```java
    // Infinite loop example (intentional)
    for (int i = 0; true; i++) {
        System.out.println("Infinite loop iteration: " + i);
        if (i > 10) { // Break condition to prevent truly infinite loop in this example
            break; // Terminate the loop when i becomes greater than 10
        }
    }
    ```

*   **Complex conditions and their readability considerations:**
    Conditions can become quite complex, especially with nested logical and relational operators. While Java allows this, it's important to prioritize readability. If a condition becomes too convoluted, consider breaking it down into simpler parts or using helper boolean variables to make the logic clearer.

    ```java
    // Example of a complex condition (less readable)
    for (int x = 1; x <= 20; x++) {
        if ((x % 2 == 0 && x % 5 != 0) || (x > 15 && x % 3 == 0)) {
            System.out.println("Number satisfying complex condition: " + x);
        }
    }

    // More readable approach using helper variables for complex conditions
    for (int x = 1; x <= 20; x++) {
        boolean condition1 = (x % 2 == 0 && x % 5 != 0);
        boolean condition2 = (x > 15 && x % 3 == 0);
        if (condition1 || condition2) {
            System.out.println("Number satisfying condition: " + x);
        }
    }
    ```

##### Increment/Decrement Part in `for` loop

This part is executed after each iteration of the loop body. It's used to update variables, often the loop counter, to control loop progression.

*   **Increment (`++`), Decrement (`--`) operators (prefix and postfix):**
    These are the most common operators used to increase or decrease the loop counter by 1 in each iteration. Both prefix (`++i`, `--i`) and postfix (`i++`, `i--`) forms can be used in the increment/decrement part of the `for` loop. In this context, the difference between prefix and postfix is usually negligible because the value of the expression isn't typically used directly in the loop control itself.

    ```java
    // Using postfix increment
    for (int i = 0; i < 5; i++) { // i is incremented after each iteration
        System.out.println("Postfix increment: " + i);
    }

    // Using prefix decrement
    for (int count = 5; count > 0; --count) { // count is decremented before the next iteration
        System.out.println("Prefix decrement: " + count);
    }
    ```

*   **Compound assignment operators (`+=`, `-=`, `*=`, `/=`):**
    You can use compound assignment operators to update the loop counter by values other than 1.

    ```java
    // Increment by 2 in each iteration
    for (int i = 0; i < 10; i += 2) {
        System.out.println("Increment by 2: " + i);
    }

    // Decrement by 3 in each iteration
    for (int j = 15; j > 0; j -= 3) {
        System.out.println("Decrement by 3: " + j);
    }
    ```

*   **Multiple updates (comma-separated - less common but valid):**
    Similar to multiple initializations, you can perform multiple updates in the increment/decrement part using commas. This can be useful when you need to update more than one variable in each iteration.

    ```java
    for (int i = 0, j = 10; i < 5; i++, j -= 2) { // i increments, j decrements in each iteration
        System.out.println("i: " + i + ", j: " + j);
    }
    ```

*   **No increment/decrement part (manual update within loop body, or condition-based termination):**
    It's possible to omit the increment/decrement part altogether. In this case, you must ensure that the loop will eventually terminate, either by manually updating variables within the loop body or by having a condition that becomes `false` based on some other logic within the loop.

    ```java
    int i = 0;
    for (; i < 5;) { // No increment/decrement part in for loop header
        System.out.println("Manual increment iteration: " + i);
        i++; // Manual increment inside the loop body
    }

    // Condition-based termination without explicit increment/decrement part
    int value = 10;
    for (; value > 0;) { // No increment/decrement part
        System.out.println("Value: " + value);
        if (value % 2 == 0) {
            value--; // Conditional decrement
        } else {
            value -= 2; // Another conditional decrement
        }
    }
    ```

##### Loop Body of `for` loop

The loop body is the block of code that gets executed repeatedly as long as the condition is `true`.

*   **Single statement loop body:**
    If the loop body consists of only one statement, you can omit the curly braces `{}`. However, for readability and to prevent errors when adding more statements later, it's generally recommended to *always* use curly braces, even for single-statement bodies.

    ```java
    for (int i = 0; i < 3; i++) // Single statement body (without braces - less recommended)
        System.out.println("Single statement: " + i);

    for (int j = 0; j < 3; j++) { // Single statement body (with braces - recommended)
        System.out.println("Single statement with braces: " + j);
    }
    ```

*   **Block statement loop body (using `{}`):**
    If the loop body contains multiple statements, you *must* use curly braces `{}` to create a block statement.

    ```java
    for (int k = 0; k < 2; k++) { // Block statement body
        System.out.println("Start of iteration: " + k);
        System.out.println("Inside loop body");
        int result = k * 2;
        System.out.println("Result: " + result);
        System.out.println("End of iteration: " + k);
    }
    ```

*   **Empty loop body (using `;` directly after `for(...)`) - use cases (e.g., timing delays):**
    You can have a `for` loop with an empty body by placing a semicolon `;` immediately after the `for(...)` part. This means the loop performs the initialization, condition check, and increment/decrement, but does nothing in the loop body itself. This is less common but can be used in specific scenarios, like creating timing delays or when the primary purpose is to iterate and the side effects are in the loop control parts (initialization, condition, increment/decrement).

    ```java
    // Empty loop body example (timing delay - not very precise in Java, better to use other methods for timing)
    long startTime = System.currentTimeMillis();
    for (int i = 0; i < 1000000; i++); // Empty loop body - just iterates
    long endTime = System.currentTimeMillis();
    System.out.println("Empty loop delay: " + (endTime - startTime) + " ms");

    // Another example: finding a specific value (though enhanced for loop is better for this)
    int[] numbers = {1, 5, 8, 12, 15};
    int index = -1;
    for (int i = 0; i < numbers.length; i++) {
        if (numbers[i] == 12) {
            index = i;
            break; // Exit loop once found
        }
    } // No explicit body, logic is within the for loop's condition and break

    if (index != -1) {
        System.out.println("Value 12 found at index: " + index);
    } else {
        System.out.println("Value 12 not found.");
    }
    ```

##### Scope of variables declared in `for` loop's initialization

Understanding variable scope is crucial for avoiding naming conflicts and managing variable lifetime.

*   **Loop scope vs. outer scope:**
    Variables declared in the initialization part of a `for` loop are typically scoped to the loop itself. This means they are only accessible within the `for` loop body and are destroyed once the loop finishes execution.

    ```java
    for (int i = 0; i < 3; i++) {
        System.out.println("Inside loop, i = " + i); // i is accessible here
    }
    // System.out.println("Outside loop, i = " + i); // Error: i is not resolved (out of scope)
    ```

*   **Variable shadowing (if variable with same name exists outside loop):**
    If you declare a variable with the same name *inside* the loop's initialization as a variable that already exists in an *outer* scope, the inner variable will "shadow" the outer variable within the loop's scope. This means that inside the loop, the name refers to the inner variable, and the outer variable is temporarily inaccessible by that name. Once the loop finishes, the scope of the inner variable ends, and the name reverts back to referring to the outer variable in the outer scope.

    ```java
    int i = 100; // Outer scope variable i

    System.out.println("Before loop, outer i = " + i); // Prints 100

    for (int i = 0; i < 3; i++) { // Inner scope variable i shadows outer i
        System.out.println("Inside loop, inner i = " + i); // Refers to inner i (0, 1, 2)
    }

    System.out.println("After loop, outer i = " + i); // Still prints 100 (outer i is unchanged)
    ```

##### `for` loop with multiple initializations and updates (comma separated) - Advanced syntax

We've already touched on this, but to reiterate, you can use commas to separate multiple initialization and update statements. This is considered slightly more advanced syntax but can be useful in specific, often more complex, loop control scenarios.

```java
for (int i = 0, j = 10; i < 5; i++, j--) {
    System.out.println("i: " + i + ", j: " + j);
}
```

##### Empty `for` loop (semicolon after the for statement) - Use cases and cautions

As mentioned before, an empty `for` loop with a semicolon `;` immediately after the `for(...)` can be used for simple delays or when the loop's primary effect is in the control parts. However, use it cautiously, as it can sometimes be less readable than other approaches if not used judiciously. For timing delays, more precise methods are usually preferred over empty loops.

##### Infinite `for` loop (`for(;;)`) and controlled termination using `break`

The `for(;;)` construct creates an infinite loop because there is no condition specified, which is implicitly treated as `true`. To make such loops useful, you must provide a way to exit them from within the loop body, typically using a `break` statement based on some condition.

```java
for (;;) { // Infinite loop
    System.out.println("This will run forever unless broken...");
    // ... some logic ...
    if (/* some exit condition */) {
        break; // Exit the loop
    }
}
```

##### `for` loop variations: decrementing loops, stepping by values other than 1.

`for` loops are not limited to incrementing by 1. You can create loops that decrement, increment by different values, or even use more complex update logic.

*   **Decrementing loops:**
    ```java
    for (int i = 10; i >= 1; i--) { // Decrementing loop
        System.out.println("Decrementing: " + i);
    }
    ```

*   **Stepping by values other than 1:**
    ```java
    // Increment by 3
    for (int i = 0; i <= 15; i += 3) {
        System.out.println("Stepping by 3: " + i);
    }

    // Decrement by 2
    for (int j = 20; j >= 0; j -= 2) {
        System.out.println("Stepping by -2: " + j);
    }
    ```

#### `while` loop

The `while` loop is used when you want to repeat a block of code as long as a condition is true, but you don't necessarily know in advance how many iterations will be needed. It's a pre-condition loop, meaning the condition is checked *before* each iteration.

##### Syntax of `while` loop (`while (condition) { ... }`)

The syntax is simpler than the `for` loop:

```java
while (condition) {
    // Loop body: code to be executed repeatedly as long as condition is true
}
```

*   **`condition`:** A boolean expression that is evaluated *before* each iteration. If `true`, the loop body executes. If `false`, the loop terminates.

##### Condition in `while` loop (same as `for` loop condition details apply - boolean expression, operators etc.)

The condition in a `while` loop works exactly the same way as the condition in a `for` loop. It's a boolean expression, and all the details about relational operators, logical operators, constant `true` conditions, and complex conditions discussed for `for` loops apply equally to `while` loops.

```java
int count = 0;
while (count < 5) { // Condition using relational operator
    System.out.println("While loop count: " + count);
    count++; // Important to update the loop variable to eventually make condition false
}

boolean running = true;
int value = 1;
while (running) { // Condition using boolean variable
    System.out.println("Value: " + value);
    if (value >= 5) {
        running = false; // Update boolean variable to terminate loop
    }
    value++;
}
```

##### Loop Body of `while` loop (single and block statement, empty loop body - same as `for` loop body details apply)

The loop body of a `while` loop behaves identically to the loop body of a `for` loop. You can have a single statement (less recommended without braces) or a block statement using `{}` (recommended). Empty loop bodies are also possible using a semicolon, but are even rarer and less common with `while` loops than with `for` loops.

```java
int i = 0;
while (i < 3) // Single statement body (less recommended)
    System.out.println("While single statement: " + i++);

int j = 0;
while (j < 3) { // Block statement body (recommended)
    System.out.println("While block statement: " + j);
    j++;
}

int delayCounter = 0;
while (delayCounter < 100000); // Empty while loop body (very rare, not recommended for delays)
```

##### Pre-condition loop nature (condition checked before each iteration)

A key characteristic of the `while` loop is that it's a *pre-condition* loop. This means the condition is evaluated *before* the loop body is executed in each iteration, including the very first iteration. If the condition is `false` initially, the loop body will not execute even once.

```java
int number = 10;
while (number < 5) { // Condition is false initially (10 is not less than 5)
    System.out.println("This will not be printed."); // Loop body never executes
    number++; // This line is never reached
}
System.out.println("Loop finished. Number is still: " + number); // number remains 10
```

##### Ensuring loop termination in `while` loops (importance of condition becoming false eventually)

For a `while` loop to terminate (unless you use `break`), it's crucial that the condition eventually becomes `false`. This typically requires updating variables within the loop body that are part of the condition, so that the condition will eventually fail.  Failing to do so leads to infinite loops.

```java
int count = 0;
while (count < 5) {
    System.out.println("Count: " + count);
    count++; // Increment count in each iteration to eventually make count >= 5
}

// Example of a potential infinite loop if you forget to update the variable
// int counter = 0;
// while (counter < 5) {
//     System.out.println("Counter: " + counter);
//     // Oops! Forgot to increment counter, condition will always be true -> infinite loop
// }
```

##### Empty `while` loop (semicolon after `while (condition);`) - very rare, potential confusion

Similar to `for` loops, you can have an empty `while` loop by placing a semicolon `;` after the condition. This is even rarer and more likely to cause confusion than empty `for` loops. It should generally be avoided unless you have a very specific and well-justified reason.

```java
int waitTime = 0;
while (waitTime < 1000); // Empty while loop - very unusual and not recommended for delays

// More likely (but still not common) use case - all logic in the condition itself
int valueToFind = 7;
int[] data = {2, 4, 6, 7, 9, 11};
int index = 0;
while (index < data.length && data[index] != valueToFind) {
    index++; // Increment index in the condition itself
} // Empty loop body - loop terminates when value is found or end of array is reached

if (index < data.length) {
    System.out.println("Value " + valueToFind + " found at index " + index);
} else {
    System.out.println("Value " + valueToFind + " not found.");
}
```

##### Infinite `while` loop (`while (true)`) and controlled termination using `break`

Similar to `for(;;)`, `while (true)` creates an infinite loop. You need to use `break` to exit such loops based on conditions within the loop body.

```java
while (true) { // Infinite while loop
    System.out.println("Infinite while loop iteration...");
    // ... some logic ...
    if (/* some exit condition */) {
        break; // Exit the loop
    }
}
```

##### Use cases for `while` loops: when the number of iterations is not known beforehand, condition-based looping.

`while` loops are ideal when you don't know in advance how many times the loop needs to run. They are perfect for situations where you need to continue looping until a certain condition is met, which might depend on user input, external data, or some computation within the loop.

*   **Reading input until a specific value is entered:**

    ```java
    import java.util.Scanner;

    public class WhileLoopInput {
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            int number;
            while (true) {
                System.out.print("Enter a positive number (or 0 to exit): ");
                number = scanner.nextInt();
                if (number == 0) {
                    break; // Exit loop if 0 is entered
                }
                if (number > 0) {
                    System.out.println("You entered: " + number);
                } else {
                    System.out.println("Please enter a positive number.");
                }
            }
            System.out.println("Exiting program.");
            scanner.close();
        }
    }
    ```

*   **Processing data from a file until end of file:**

    ```java
    import java.io.BufferedReader;
    import java.io.FileReader;
    import java.io.IOException;

    public class WhileLoopFile {
        public static void main(String[] args) {
            String fileName = "data.txt"; // Assume data.txt exists
            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
                String line;
                while ((line = reader.readLine()) != null) { // Read line until end of file (null)
                    System.out.println("Line from file: " + line);
                    // Process the line
                }
            } catch (IOException e) {
                System.err.println("Error reading file: " + e.getMessage());
            }
        }
    }
    ```

#### `do-while` loop

The `do-while` loop is similar to the `while` loop, but it's a *post-condition* loop. This means the condition is checked *after* the loop body executes. As a result, the loop body is guaranteed to execute at least once, regardless of the initial condition.

##### Syntax of `do-while` loop (`do { ... } while (condition);`)

```java
do {
    // Loop body: code to be executed at least once, and then repeatedly
    // as long as condition is true
} while (condition); // Note the semicolon at the end
```

*   **`do { ... }`:**  Encloses the loop body.
*   **`while (condition);`:** The condition is checked *after* the loop body executes. If `true`, the loop body is executed again. If `false`, the loop terminates. *Crucially, note the semicolon `;` at the end of the `while (condition);` line.*

##### Condition in `do-while` loop (same condition details as `for` and `while`)

The condition in a `do-while` loop is a boolean expression and functions identically to the conditions in `for` and `while` loops.

##### Loop Body of `do-while` loop (single and block statement, empty loop body - technically possible but highly unusual and not recommended)

Similar to `for` and `while` loops, the loop body can be a single statement or a block statement using `{}`. While technically you could have an empty `do-while` loop (using a semicolon within the `do` block, like `do ; while(condition);`), it's extremely unusual and almost never recommended. An empty `do-while` loop is very likely to be a mistake.

```java
int i = 0;
do // Single statement body (less recommended)
    System.out.println("Do-while single statement: " + i++);
while (i < 3);

int j = 0;
do { // Block statement body (recommended)
    System.out.println("Do-while block statement: " + j);
    j++;
} while (j < 3);

// Empty do-while loop - technically possible, but highly unlikely to be useful and confusing
// do ; while (false);
```

##### Post-condition loop nature (condition checked after each iteration)

The defining feature of the `do-while` loop is that it's a post-condition loop. The loop body is executed *first*, and then the condition is checked. This guarantees at least one execution of the loop body.

```java
int number = 10;
do {
    System.out.println("Do-while loop, number: " + number); // This will be printed once, even though number is initially 10
    number++;
} while (number < 5); // Condition is false initially (10 is not less than 5), but body executed once
System.out.println("Loop finished. Number is now: " + number); // number is 11
```

##### Execution of loop body at least once (guaranteed first iteration)

This is the key differentiator from `while` loops. `do-while` loops are used when you need to perform an action at least once, and then repeat it based on a condition.

##### Difference between `while` and `do-while` loop (when to choose which)

*   **`while` loop:** Pre-condition loop. Condition is checked *before* each iteration. Loop body may not execute at all if the condition is initially false. Use when you want to execute a block of code zero or more times based on a condition.
*   **`do-while` loop:** Post-condition loop. Condition is checked *after* each iteration. Loop body is guaranteed to execute at least once. Use when you need to execute a block of code at least once, and then potentially repeat it based on a condition.

##### Empty `do-while` loop (semicolon after `while (condition);` - same as `while`, not recommended)

Similar to empty `while` loops, empty `do-while` loops are also possible but highly unusual and not recommended. They are even more likely to be unintentional errors.

##### Infinite `do-while` loop (`do { ... } while (true)`) and controlled termination using `break`

Like `for(;;)` and `while(true)`, `do { ... } while (true)` creates an infinite loop. Use `break` to exit based on conditions within the loop body.

```java
do {
    System.out.println("Infinite do-while loop iteration...");
    // ... some logic ...
    if (/* some exit condition */) {
        break; // Exit the loop
    }
} while (true);
```

##### Use cases for `do-while` loops: scenarios requiring at least one execution, input validation loops.

`do-while` loops are particularly useful in scenarios where you must perform an action at least once, such as:

*   **Input validation:** You need to ask for input, and keep asking until valid input is provided.

    ```java
    import java.util.Scanner;

    public class DoWhileInputValidation {
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            int age;
            do {
                System.out.print("Enter your age (must be non-negative): ");
                age = scanner.nextInt();
                if (age < 0) {
                    System.out.println("Age cannot be negative. Please try again.");
                }
            } while (age < 0); // Keep looping until age is non-negative
            System.out.println("Valid age entered: " + age);
            scanner.close();
        }
    }
    ```

*   **Menu-driven programs:** Display a menu, get user choice, perform action, and then repeat the menu until the user chooses to exit.

    ```java
    import java.util.Scanner;

    public class DoWhileMenu {
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            int choice;
            do {
                System.out.println("\nMenu:");
                System.out.println("1. Option 1");
                System.out.println("2. Option 2");
                System.out.println("3. Exit");
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();

                switch (choice) {
                    case 1:
                        System.out.println("Performing Option 1...");
                        // Action for option 1
                        break;
                    case 2:
                        System.out.println("Performing Option 2...");
                        // Action for option 2
                        break;
                    case 3:
                        System.out.println("Exiting menu.");
                        break;
                    default:
                        System.out.println("Invalid choice. Please try again.");
                }
            } while (choice != 3); // Continue menu until user chooses option 3 (Exit)
            scanner.close();
        }
    }
    ```

#### Enhanced `for` loop (for-each loop)

The enhanced `for` loop, often called the for-each loop, is designed for iterating over elements of collections (like arrays, Lists, Sets, etc.) in a more concise and readable way. It simplifies iteration when you just need to access each element in sequence without needing to manage indices explicitly.

##### Syntax of enhanced `for` loop (`for (dataType item : collection) { ... }`)

```java
for (dataType item : collection) {
    // Loop body: code to be executed for each item in the collection
    // 'item' represents the current element in each iteration
}
```

*   **`dataType item`:** Declares a variable `item` of type `dataType`. In each iteration, `item` will hold the current element from the `collection`. The `dataType` must be compatible with the type of elements in the `collection`.
*   **`: collection`:**  Specifies the collection (array or Iterable) you want to iterate over.
*   **Loop body:**  The code to be executed for each element in the collection. Inside the loop body, you can use the `item` variable to access the current element.

##### Iterating over arrays using enhanced `for` loop

*   **Accessing array elements sequentially:** The enhanced `for` loop automatically iterates through the array from the first element to the last.

    ```java
    int[] numbers = {10, 20, 30, 40, 50};
    for (int number : numbers) { // Iterate over each element in 'numbers' array
        System.out.println("Number: " + number);
    }
    ```

*   **Read-only access to array elements:** By default, the enhanced `for` loop provides read-only access to the elements.  While you can change the value of the loop variable `item` inside the loop body, this does *not* modify the original element in the array (for primitive types like `int`, `double`, etc.). For objects, you are working with a reference, so you can modify the *state* of the object, but you cannot replace the object in the array using just the loop variable.

    ```java
    int[] values = {1, 2, 3};
    for (int val : values) {
        val = val * 10; // Modifying 'val' (loop variable)
        System.out.println("Inside loop, val = " + val); // val is changed here
    }
    // Original array 'values' is unchanged
    for (int originalVal : values) {
        System.out.println("Original value in array: " + originalVal); // Prints 1, 2, 3
    }

    String[] names = {"Alice", "Bob"};
    for (String name : names) {
        name = "Mr. " + name; // Modifying 'name' (loop variable) - String is immutable
        System.out.println("Inside loop, name = " + name); // name is changed here
    }
    // Original array 'names' is unchanged
    for (String originalName : names) {
        System.out.println("Original name in array: " + originalName); // Prints Alice, Bob
    }
    ```

##### Iterating over Collections (like `List`, `Set`, etc.) using enhanced `for` loop

The enhanced `for` loop works seamlessly with Java Collections Framework interfaces like `List`, `Set`, `Queue`, etc., as they implement the `Iterable` interface.

*   **Iterating over elements in collection order (for ordered collections like `List`):** For ordered collections like `ArrayList` and `LinkedList`, the enhanced `for` loop iterates in the order elements were added to the list.

    ```java
    import java.util.ArrayList;
    import java.util.List;

    public class EnhancedForList {
        public static void main(String[] args) {
            List<String> fruits = new ArrayList<>();
            fruits.add("Apple");
            fruits.add("Banana");
            fruits.add("Cherry");

            for (String fruit : fruits) { // Iterating over ArrayList (ordered)
                System.out.println("Fruit: " + fruit); // Prints in order: Apple, Banana, Cherry
            }
        }
    }
    ```

*   **Iteration order for unordered collections (like `HashSet` - order not guaranteed):** For unordered collections like `HashSet`, the iteration order is not guaranteed to be the insertion order and might even change between runs. You should not rely on a specific order when iterating over unordered collections with the enhanced `for` loop.

    ```java
    import java.util.HashSet;
    import java.util.Set;

    public class EnhancedForSet {
        public static void main(String[] args) {
            Set<String> colors = new HashSet<>();
            colors.add("Red");
            colors.add("Green");
            colors.add("Blue");

            for (String color : colors) { // Iterating over HashSet (unordered)
                System.out.println("Color: " + color); // Order is not guaranteed, might vary
            }
        }
    }
    ```

##### Read-only iteration nature (cannot directly modify the original collection during iteration in straightforward ways in all cases)

Similar to arrays, enhanced `for` loops provide read-only access in the sense that you cannot directly replace elements in the original collection using the loop variable. However, for collections of objects, you can modify the *state* of the objects referenced by the loop variable.

Furthermore, you generally cannot safely modify the *structure* of the collection (add or remove elements) while iterating over it with an enhanced `for` loop, as this can lead to `ConcurrentModificationException` in many standard Java collections.

##### Limitations of enhanced `for` loop

While convenient, the enhanced `for` loop has limitations:

*   **No index access (cannot get the index of the current element directly):** You don't have access to the index of the current element being processed. If you need the index, you must use a traditional `for` loop with an index counter.

    ```java
    String[] names = {"Alice", "Bob", "Charlie"};
    // Enhanced for loop - no index
    for (String name : names) {
        System.out.println("Name: " + name); // Just the name, no index
    }

    // Traditional for loop - index available
    for (int i = 0; i < names.length; i++) {
        System.out.println("Index " + i + ": Name = " + names[i]); // Index available
    }
    ```

*   **Cannot modify the collection being iterated over *while* iterating (concurrent modification exceptions in some cases, especially with standard collections - though more complex scenarios exist):**  Adding or removing elements from the collection you are iterating over using the enhanced `for` loop can lead to `ConcurrentModificationException` with standard collections like `ArrayList`, `HashSet`, etc. This is because the enhanced `for` loop typically uses an iterator internally, and structural modifications during iteration can invalidate the iterator's state.

    ```java
    import java.util.ArrayList;
    import java.util.List;

    public class EnhancedForModification {
        public static void main(String[] args) {
            List<Integer> numbers = new ArrayList<>();
            numbers.add(1);
            numbers.add(2);
            numbers.add(3);

            // Example of attempt to modify list during enhanced for loop - will likely throw ConcurrentModificationException
            try {
                for (Integer number : numbers) {
                    System.out.println("Processing number: " + number);
                    if (number == 2) {
                        numbers.remove(number); // Attempting to remove element during iteration - problematic
                    }
                }
            } catch (java.util.ConcurrentModificationException e) {
                System.err.println("ConcurrentModificationException caught: " + e.getMessage());
            }

            System.out.println("List after attempted modification: " + numbers); // List may be in an inconsistent state
        }
    }
    ```
    If you need to modify a collection while iterating, you typically need to use an explicit `Iterator` and its `remove()` method (for removals) or use other techniques depending on the specific modification needed.

*   **Not suitable for all collection types (e.g., iterators might be needed for more advanced collection manipulation during iteration):** For more complex operations during iteration, especially when you need to modify the collection or control iteration more finely (like removing elements based on conditions, iterating backwards, etc.), you might need to use an explicit `Iterator` instead of the enhanced `for` loop.

*   **Cannot iterate backwards using enhanced for loop directly:** The enhanced `for` loop always iterates in the forward direction. To iterate backwards, you must use a traditional `for` loop and iterate using indices in reverse order.

##### Use cases for enhanced `for` loop: simple iteration when index is not needed, iterating over collections and arrays for read-only purposes.

The enhanced `for` loop is excellent for:

*   **Simple iteration when you just need to process each element:** When you want to perform an operation on every element of an array or collection without needing the index.
*   **Read-only iteration:** When you are just reading or accessing elements and not modifying the structure of the collection during iteration.
*   **Improved readability:** It often makes the code more concise and easier to read compared to traditional indexed loops, especially when dealing with collections.

### Loop Control Statements

Loop control statements allow you to alter the normal flow of loop execution. Java provides two main loop control statements: `break` and `continue`.

#### `break` statement

The `break` statement is used to immediately terminate a loop and transfer control to the statement immediately following the loop.

##### Using `break` to exit a loop prematurely (unconditional exit)

When a `break` statement is encountered inside a loop, the loop execution stops immediately, regardless of whether the loop condition is still true.

##### `break` statement in `for` loop (immediate exit from the `for` loop)

```java
for (int i = 0; i < 10; i++) {
    System.out.println("Iteration: " + i);
    if (i == 3) {
        System.out.println("Breaking out of loop at i = 3");
        break; // Exit the for loop immediately when i is 3
    }
}
System.out.println("After for loop");
```

##### `break` statement in `while` loop (immediate exit from the `while` loop)

```java
int count = 0;
while (count < 10) {
    System.out.println("Count: " + count);
    count++;
    if (count == 5) {
        System.out.println("Breaking out of while loop at count = 5");
        break; // Exit the while loop immediately when count is 5
    }
}
System.out.println("After while loop");
```

##### `break` statement in `do-while` loop (immediate exit from the `do-while` loop)

```java
int value = 1;
do {
    System.out.println("Value: " + value);
    value++;
    if (value == 4) {
        System.out.println("Breaking out of do-while loop at value = 4");
        break; // Exit the do-while loop immediately when value is 4
    }
} while (value < 10);
System.out.println("After do-while loop");
```

##### `break` in nested loops (exiting the *innermost* loop only)

When you have nested loops, a `break` statement within an inner loop will only terminate the *innermost* loop in which it is directly contained. Execution will continue with the next iteration of the outer loop (if there is one) or with the statements following the outer loop.

```java
for (int i = 1; i <= 3; i++) { // Outer loop
    System.out.println("Outer loop iteration: " + i);
    for (int j = 1; j <= 3; j++) { // Inner loop
        System.out.println("  Inner loop iteration: " + j);
        if (j == 2) {
            System.out.println("    Breaking from inner loop when j = 2");
            break; // Breaks out of the inner loop only
        }
    }
    System.out.println("Continuing with outer loop iteration " + i); // Outer loop continues
}
System.out.println("After nested loops");
```

##### Labeled `break` (breaking out of *outer* loops in nested structures)

To break out of an *outer* loop from within a nested structure, Java provides labeled `break`.

*   **Syntax of labeled `break` (`break labelName;`)**
    *   **Defining labels for loops (`labelName: for(...)`)**
        To use a labeled `break`, you first need to label the outer loop you want to break out of. You do this by placing a label (an identifier followed by a colon `:`) immediately before the loop. Then, in the inner loop, you use `break labelName;` to break out of the loop associated with that label.

        ```java
        outerLoop: // Label for the outer loop
        for (int i = 1; i <= 3; i++) {
            System.out.println("Outer loop iteration: " + i);
            innerLoop: // Label for the inner loop (optional, for demonstration)
            for (int j = 1; j <= 3; j++) {
                System.out.println("  Inner loop iteration: " + j);
                if (i == 2 && j == 2) {
                    System.out.println("    Breaking out of outer loop from inner loop when i=2, j=2");
                    break outerLoop; // Break out of the loop labeled 'outerLoop'
                }
            }
            System.out.println("This line will not be reached when outer loop is broken.");
        }
        System.out.println("After outer loop (reached after labeled break)");
        ```

*   **Use cases for labeled `break` (complex nested loop scenarios, improving readability in specific cases)**
    Labeled `break` is useful in deeply nested loops or when you have complex conditional logic and need to exit multiple levels of loops based on a specific condition. It can sometimes improve readability in such scenarios by making the exit condition more explicit.

*   **Potential for decreased readability if overused.**
    While labeled `break` can be helpful, overuse can make code harder to follow, especially if labels are far from the `break` statement or if there are many labeled breaks. In many cases, restructuring your loop logic or using boolean flags might be a more readable alternative to excessive use of labeled `break`. Use it judiciously when it genuinely clarifies the control flow in complex nested structures.

#### `continue` statement

The `continue` statement is used to skip the rest of the current iteration of a loop and jump to the next iteration. It does not terminate the loop entirely, but rather moves to the next cycle.

##### Using `continue` to skip to the next iteration of a loop (skipping the rest of the current iteration's body)

When a `continue` statement is encountered, the remaining statements in the current iteration's loop body are skipped, and the loop proceeds to the next iteration.

##### `continue` statement in `for` loop (jumps to the increment/decrement part, then condition check)

In a `for` loop, `continue` causes the program to jump to the increment/decrement part of the `for` loop header, and then the condition is checked for the next iteration.

```java
for (int i = 0; i < 5; i++) {
    if (i == 2) {
        System.out.println("Continue at i = 2, skipping rest of iteration");
        continue; // Skip rest of loop body for i = 2, go to increment
    }
    System.out.println("Iteration: " + i);
}
System.out.println("After for loop");
```

##### `continue` statement in `while` loop (jumps directly to the condition check)

In a `while` loop, `continue` causes the program to jump directly to the condition check at the beginning of the next iteration.

```java
int count = 0;
while (count < 5) {
    count++; // Increment count at the beginning to avoid infinite loop if continue is reached
    if (count == 3) {
        System.out.println("Continue at count = 3, skipping rest of iteration");
        continue; // Skip rest of loop body for count = 3, go to condition check
    }
    System.out.println("Count: " + count);
}
System.out.println("After while loop");
```

##### `continue` statement in `do-while` loop (jumps directly to the condition check)

In a `do-while` loop, `continue` also causes the program to jump directly to the condition check at the `while (condition);` part, initiating the next iteration if the condition is true.

```java
int value = 0;
do {
    value++; // Increment value at the beginning to avoid infinite loop if continue is reached
    if (value == 2) {
        System.out.println("Continue at value = 2, skipping rest of iteration");
        continue; // Skip rest of loop body for value = 2, go to condition check
    }
    System.out.println("Value: " + value);
} while (value < 5);
System.out.println("After do-while loop");
```

##### `continue` in nested loops (skipping iteration of the *innermost* loop only)

Similar to `break`, in nested loops, `continue` only affects the *innermost* loop in which it is used. It will skip the rest of the current iteration of the inner loop and start the next iteration of that inner loop. The outer loop continues its current iteration.

```java
for (int i = 1; i <= 3; i++) { // Outer loop
    System.out.println("Outer loop iteration: " + i);
    for (int j = 1; j <= 3; j++) { // Inner loop
        if (j == 2) {
            System.out.println("  Continue in inner loop when j = 2, skip rest of inner iteration");
            continue; // Continue to next iteration of inner loop
        }
        System.out.println("  Inner loop iteration: " + j);
    }
    System.out.println("Continuing with outer loop iteration " + i); // Outer loop continues normally
}
System.out.println("After nested loops");
```

##### Labeled `continue` (continuing to the next iteration of an *outer* loop in nested structures)

Just as with `break`, you can use labeled `continue` to jump to the next iteration of an *outer* loop from within a nested loop structure.

*   **Syntax of labeled `continue` (`continue labelName;`)**
    Using the same loop labels defined earlier, `continue labelName;` will skip the rest of the current iteration of the loop labeled `labelName` and jump to the next iteration of that outer loop.

    ```java
    outerLoop: // Label for the outer loop
    for (int i = 1; i <= 3; i++) {
        System.out.println("Outer loop iteration: " + i);
        innerLoop: // Label for the inner loop (optional, for demonstration)
        for (int j = 1; j <= 3; j++) {
            if (i == 2 && j == 2) {
                System.out.println("  Continue outer loop from inner loop when i=2, j=2");
                continue outerLoop; // Continue to the next iteration of the loop labeled 'outerLoop'
            }
            System.out.println("  Inner loop iteration: " + j);
        }
        System.out.println("This line will not be reached when outer loop is continued.");
    }
    System.out.println("After outer loop (reached after labeled continue)");
    ```

*   **Use cases for labeled `continue` (complex nested loop scenarios, skipping iterations in outer loops based on inner loop conditions)**
    Labeled `continue` is useful in complex nested loops where you need to skip to the next iteration of an outer loop based on a condition in an inner loop. It can help in situations where you need to process data in a structured way and skip entire iterations of an outer loop based on inner loop logic.

*   **Potential for decreased readability if overused.**
    Similar to labeled `break`, overuse of labeled `continue` can also reduce code readability. It's important to use it only when it genuinely makes the control flow clearer in complex nested situations. Often, rethinking the loop structure or using boolean flags can provide more readable alternatives.

##### Difference between `break` and `continue` (exit vs. skip iteration).

*   **`break`:** Terminates the loop *entirely*. Execution jumps to the statement immediately after the loop.
*   **`continue`:** Skips the *rest of the current iteration* of the loop body and proceeds to the *next iteration*. For `for` loops, it goes to the increment/decrement part, then condition check. For `while` and `do-while` loops, it goes directly to the condition check.

### Nested Loops

Nested loops occur when one loop is placed inside another loop. This is a common and powerful technique for processing multi-dimensional data or performing repetitive tasks that have a hierarchical structure.

#### Concept of nested loops (loop inside another loop)

A nested loop simply means one loop (inner loop) is entirely contained within the body of another loop (outer loop). You can have loops nested to multiple levels, but typically nesting beyond 2-3 levels can become complex and harder to manage.

#### Outer loop and Inner loop (terminology and roles)

*   **Outer loop:** The loop that contains the inner loop. It controls the overall iterations. For each iteration of the outer loop, the entire inner loop executes.
*   **Inner loop:** The loop that is nested inside the outer loop. It executes completely for each single iteration of the outer loop.

#### Execution flow of nested loops (inner loop completes all iterations for each iteration of the outer loop)

The execution flow is as follows:

1.  The outer loop starts its first iteration.
2.  As soon as the outer loop body is entered, the inner loop starts.
3.  The inner loop executes completely for all its iterations.
4.  Once the inner loop finishes, execution returns to the outer loop body to complete the rest of its first iteration.
5.  The outer loop proceeds to its next iteration.
6.  Steps 2-5 are repeated for each iteration of the outer loop until the outer loop condition becomes false.

```java
for (int i = 1; i <= 3; i++) { // Outer loop
    System.out.println("Outer loop iteration: " + i);
    for (int j = 1; j <= 2; j++) { // Inner loop
        System.out.println("  Inner loop iteration: " + j);
        System.out.println("  i * j = " + (i * j));
    }
    System.out.println("Outer loop iteration " + i + " finished.");
}
System.out.println("Nested loops finished.");
```

Output:

```
Outer loop iteration: 1
  Inner loop iteration: 1
  i * j = 1
  Inner loop iteration: 2
  i * j = 2
Outer loop iteration 1 finished.
Outer loop iteration: 2
  Inner loop iteration: 1
  i * j = 2
  Inner loop iteration: 2
  i * j = 4
Outer loop iteration 2 finished.
Outer loop iteration: 3
  Inner loop iteration: 1
  i * j = 3
  Inner loop iteration: 2
  i * j = 6
Outer loop iteration 3 finished.
Nested loops finished.
```

Notice how for each value of `i` (outer loop), the inner loop with `j` runs completely (from 1 to 2).

#### Initialization, condition, and increment/decrement in nested loops (each loop has its own control variables and conditions)

Each loop in a nested structure has its own independent initialization, condition, and increment/decrement parts. They operate separately. The outer loop's control variables and conditions manage the outer loop's iterations, and the inner loop's control variables and conditions manage the inner loop's iterations, independently, but within the context of each outer loop iteration.

```java
for (int row = 1; row <= 3; row++) { // Outer loop controls rows
    for (int col = 1; col <= 4; col++) { // Inner loop controls columns for each row
        System.out.print("(" + row + "," + col + ") "); // Print coordinate
    }
    System.out.println(); // New line after each row
}
```

Output:

```
(1,1) (1,2) (1,3) (1,4)
(2,1) (2,2) (2,3) (2,4)
(3,1) (3,2) (3,3) (3,4)
```

Here, `row` is controlled by the outer loop, and `col` by the inner loop. For each `row`, `col` iterates from 1 to 4.

#### Using `break` and `continue` in nested loops (affects the loop where they are directly used, unless labeled)

As discussed earlier, `break` and `continue` within a nested loop, without labels, only affect the loop in which they are directly used (typically the innermost loop). To affect outer loops, you need to use labeled `break` and `continue`.

#### Applications of nested loops

Nested loops are used in a wide range of applications:

*   **Iterating 2D arrays/matrices (row-major and column-major traversal):**
    Nested loops are the standard way to process 2D arrays.

    ```java
    int[][] matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    // Row-major traversal (process row by row)
    System.out.println("Row-major traversal:");
    for (int i = 0; i < matrix.length; i++) { // Outer loop for rows
        for (int j = 0; j < matrix[i].length; j++) { // Inner loop for columns in each row
            System.out.print(matrix[i][j] + " ");
        }
        System.out.println();
    }

    // Column-major traversal (process column by column - less common for 2D arrays)
    System.out.println("\nColumn-major traversal:");
    for (int j = 0; j < matrix[0].length; j++) { // Outer loop for columns
        for (int i = 0; i < matrix.length; i++) { // Inner loop for rows in each column
            System.out.print(matrix[i][j] + " ");
        }
        System.out.println();
    }
    ```

*   **Generating patterns (stars, numbers, etc.):**
    Nested loops are commonly used to generate patterns in text, like triangles, squares, pyramids, etc.

    ```java
    // Example: Printing a right-angled triangle of stars
    int rows = 5;
    for (int i = 1; i <= rows; i++) { // Outer loop for rows
        for (int j = 1; j <= i; j++) { // Inner loop to print stars in each row
            System.out.print("* ");
        }
        System.out.println(); // New line after each row
    }
    ```

*   **Comparing elements in two collections (nested iteration for pairwise comparison):**
    When you need to compare every element of one collection with every element of another, nested loops are used.

    ```java
    int[] list1 = {1, 2, 3};
    int[] list2 = {2, 3, 4};

    for (int val1 : list1) { // Outer loop for list1
        for (int val2 : list2) { // Inner loop for list2
            if (val1 == val2) {
                System.out.println(val1 + " is present in both lists.");
            }
        }
    }
    ```

*   **Algorithms involving nested iterations (e.g., simple sorting algorithms like bubble sort):**
    Many algorithms, especially simpler sorting algorithms like bubble sort, insertion sort, and selection sort, use nested loops to compare and rearrange elements.

    ```java
    // Simple Bubble Sort example
    int[] arrayToSort = {5, 1, 4, 2, 8};
    int n = arrayToSort.length;
    for (int i = 0; i < n - 1; i++) { // Outer loop for passes
        for (int j = 0; j < n - i - 1; j++) { // Inner loop for comparisons in each pass
            if (arrayToSort[j] > arrayToSort[j + 1]) {
                // Swap arrayToSort[j] and arrayToSort[j+1]
                int temp = arrayToSort[j];
                arrayToSort[j] = arrayToSort[j + 1];
                arrayToSort[j + 1] = temp;
            }
        }
    }
    System.out.println("Sorted array:");
    for (int num : arrayToSort) {
        System.out.print(num + " ");
    }
    System.out.println();
    ```

#### Complexity of nested loops (time complexity implications - e.g., O(n*m) for nested loops)

Nested loops significantly impact the time complexity of algorithms. If an outer loop runs `n` times and an inner loop runs `m` times for each iteration of the outer loop, the total number of operations performed by the inner loop body will be roughly proportional to `n * m`. This leads to a time complexity of O(n*m).

*   **Example:** If both outer and inner loops iterate `n` times (e.g., processing an `n x n` matrix), the complexity becomes O(n*n) or O(n<sup>2</sup>).

    ```java
    // Example of O(n^2) complexity due to nested loops
    int n = 100; // Assume n is large
    int operationsCount = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            operationsCount++; // This operation is performed n*n times
        }
    }
    System.out.println("Total operations in O(n^2) nested loops (n=" + n + "): " + operationsCount); // Close to n*n
    ```

    For algorithms dealing with large datasets, nested loops can become a performance bottleneck if not used carefully. In such cases, consider if the nested loop structure is necessary or if there are more efficient algorithms or data structures that can reduce the complexity (e.g., from O(n<sup>2</sup>) to O(n log n) or O(n)).

#### Nested loops with different loop types (e.g., `for` loop inside `while` loop, etc.)

You can freely mix different types of loops in nested structures. For example, you can have a `for` loop as the outer loop and a `while` loop as the inner loop, or vice versa, or any combination of `for`, `while`, and `do-while` loops. The choice depends on the logic and conditions you need for each level of iteration.

```java
int i = 1;
while (i <= 3) { // Outer while loop
    System.out.println("Outer loop (while) iteration: " + i);
    for (int j = 1; j <= 2; j++) { // Inner for loop
        System.out.println("  Inner loop (for) iteration: " + j);
    }
    i++;
}
System.out.println("Nested loops finished.");
```

### Looping Concepts and Best Practices

Effective use of loops involves understanding several key concepts and following best practices to write clear, efficient, and maintainable code.

#### Loop Initialization (setting up variables before loop starts - initial values, data structures)

Before starting a loop, it's often necessary to initialize variables that will be used within the loop or to control the loop's execution. This might include:

*   **Loop counter variables:** Setting initial values for loop counters (e.g., `int i = 0;` for a `for` loop).
*   **Accumulator variables:** Initializing variables to store results (e.g., `int sum = 0;` for summing numbers).
*   **Data structures:** Setting up collections or arrays that will be processed in the loop.
*   **Flags or control variables:** Initializing boolean flags or other variables that control loop conditions.

```java
int sum = 0; // Initialize accumulator variable
int[] numbers = {1, 2, 3, 4, 5}; // Initialize data structure

for (int number : numbers) {
    sum += number; // Accumulate sum in each iteration
}
System.out.println("Sum of numbers: " + sum);
```

#### Loop Condition (Boolean expression that determines loop execution - clarity, correctness, termination guarantee)

The loop condition is the heart of loop control. It's crucial to:

*   **Ensure clarity:** Make sure the condition is easy to understand and accurately reflects when the loop should continue or terminate. Avoid overly complex or obscure conditions if possible.
*   **Ensure correctness:** The condition must be logically correct to achieve the desired loop behavior. Incorrect conditions are a common source of bugs, including infinite loops or loops that terminate prematurely.
*   **Guarantee termination:** For most loops (except intentional infinite loops), the condition must eventually become `false` to prevent an infinite loop. Ensure that variables involved in the condition are updated within the loop body in a way that leads to the condition becoming false.

#### Loop Iteration (single pass through the loop body - understanding what happens in each iteration)

Understand what happens in each single pass (iteration) of the loop body. This involves:

*   **Variable updates:** How are loop counter variables, accumulators, or other variables modified in each iteration?
*   **Data processing:** What operations are performed on the data in each iteration?
*   **Conditional logic:** Are there any `if` statements or other conditional checks within the loop body that affect the flow of execution in each iteration?

#### Loop Body (statements executed in each iteration - efficiency, clarity, avoiding side effects where not intended)

The loop body contains the core logic that is repeated. Consider these aspects:

*   **Efficiency:** Avoid unnecessary computations within the loop body, especially if they are invariant (same in every iteration). Move invariant calculations outside the loop if possible.
*   **Clarity:** Keep the loop body concise and focused on its primary purpose. If the loop body becomes too long or complex, consider refactoring it into separate methods to improve readability and maintainability.
*   **Side effects:** Be aware of side effects within the loop body (e.g., modifying variables outside the loop scope, performing I/O operations). Ensure these side effects are intended and don't lead to unexpected behavior.
*   **Avoid modifying loop control variables unintentionally:** Be careful not to modify loop counter variables or variables that are part of the loop condition within the loop body unless it's intentional and well-understood. Unintentional modifications can lead to unexpected loop behavior or infinite loops.

#### Loop Variable / Loop Counter (variable used to control loop iterations - naming conventions, scope, purpose)

*   **Naming conventions:** Use descriptive names for loop counter variables, especially in nested loops or complex scenarios. Common conventions include `i`, `j`, `k` for simple `for` loops, or more descriptive names like `rowIndex`, `columnIndex`, `itemIndex`, etc., when appropriate.
*   **Scope:** Understand the scope of loop variables. Variables declared in the initialization part of a `for` loop typically have loop scope. Variables declared outside the loop have a wider scope. Be mindful of variable shadowing.
*   **Purpose:** Clearly understand the purpose of the loop variable. Is it just a counter, or does it also represent an index, an element value, or some other meaningful quantity in each iteration?

#### Infinite Loops (loops that never terminate due to condition always being true)

Infinite loops are a common issue, especially during development.

*   **Causes of infinite loops (logical errors in conditions, incorrect update of loop variables):**
    *   **Condition always true:** The loop condition is designed in a way that it never becomes `false`. (e.g., `while (true)` without a `break`).
    *   **Incorrect update of loop variables:** Variables involved in the loop condition are not updated correctly within the loop body, or are not updated at all, so the condition never changes to `false`.
    *   **Logical errors in condition logic:** Mistakes in the boolean logic of the condition itself, causing it to always evaluate to `true` under the intended circumstances.

*   **How to avoid infinite loops (careful condition design, ensuring progress towards termination condition):**
    *   **Carefully design loop conditions:** Ensure the condition will eventually become `false` under normal execution.
    *   **Verify variable updates:** Double-check that loop counter variables or variables affecting the condition are correctly updated in each iteration in a way that moves towards the termination condition.
    *   **Test loop termination:** Test your loop with various inputs and scenarios to ensure it terminates as expected in all cases.

*   **Debugging infinite loops (using debuggers, print statements to track loop variable values):**
    *   **Debuggers:** Use a debugger to step through the loop iteration by iteration, inspect variable values, and understand the flow of execution. This is often the most effective way to find the cause of infinite loops.
    *   **Print statements:** Temporarily add `System.out.println()` statements inside the loop to print the values of loop variables and conditions in each iteration. This can help you see if variables are behaving as expected and if the condition is ever becoming `false`. Remove or comment out these print statements once debugging is complete.
    *   **Task managers/Process monitors:** If your program gets stuck in an infinite loop and consumes excessive resources, use task managers or process monitors to identify and terminate the running process.

*   **Intentional infinite loops (server applications, event loops) and controlled exit mechanisms (`break`, external signals):**
    In some specific applications (like server applications, event-driven systems, game loops), infinite loops are intentional. These loops are designed to run continuously, waiting for events or requests. They must have controlled exit mechanisms, typically using:
    *   **`break` statements:** To exit the loop based on specific internal conditions (e.g., a shutdown signal).
    *   **External signals:** Responding to external signals (like user input to terminate, operating system signals, etc.) to break out of the loop and shut down gracefully.

#### Loop Termination (conditions for a loop to stop executing - explicit conditions, implicit conditions through `break`)

Loops terminate when their condition becomes `false`. This can happen:

*   **Explicit condition:** The loop condition itself evaluates to `false` (e.g., `i < 10` becomes `false` when `i` reaches 10). This is the most common and natural way for loops to terminate.
*   **Implicit condition through `break`:** A `break` statement is executed within the loop body, regardless of the loop condition. This provides a way to terminate the loop prematurely based on logic inside the loop body.

#### Choosing the right type of loop (`for`, `while`, `do-while`, enhanced `for`) based on the situation.

*   **`for` loop:**
    *   **Use when:** The number of iterations is known in advance or easily determined (e.g., iterating a fixed number of times, iterating over an array or list using indices).
    *   **Characteristics:** Initialization, condition, increment/decrement are all in one place, making it good for count-controlled loops.

*   **`while` loop:**
    *   **Use when:** The number of iterations is not known in advance, and loop execution depends on a condition that is checked *before* each iteration.
    *   **Characteristics:** Pre-condition loop. Good for condition-based loops, reading input until a condition is met, processing data streams, etc.

*   **`do-while` loop:**
    *   **Use when:** You need to execute the loop body at least once, and then continue looping based on a condition checked *after* each iteration.
    *   **Characteristics:** Post-condition loop. Good for input validation, menu-driven programs, situations where you need to perform an action and then decide whether to repeat it.

*   **Enhanced `for` loop (for-each loop):**
    *   **Use when:** You need to iterate over elements of collections (arrays, Lists, Sets, etc.) in a simple, read-only manner, and you don't need index access.
    *   **Characteristics:** Concise syntax, improved readability for collection iteration. Best for simple iteration when you just need to process each element.

#### Loop efficiency considerations (basic to intermediate level)

While often not the primary concern for simple programs, loop efficiency can become important in performance-critical applications or when dealing with large datasets.

*   **Avoiding unnecessary computations inside loops (moving invariant calculations outside):**
    If a calculation inside a the loop body produces the same result in every iteration, move it outside the loop to avoid redundant computations.

    ```java
    // Inefficient: square root calculated in each iteration
    for (int i = 0; i < 1000; i++) {
        double sqrtValue = Math.sqrt(10); // Invariant calculation
        System.out.println(i * sqrtValue);
    }

    // Efficient: square root calculated once, outside the loop
    double sqrt10 = Math.sqrt(10); // Calculate once
    for (int i = 0; i < 1000; i++) {
        System.out.println(i * sqrt10); // Use pre-calculated value
    }
    ```

*   **Minimizing object creation inside loops (if possible and performance-critical):**
    Creating new objects inside loops, especially in tight loops, can be computationally expensive due to object allocation and garbage collection overhead. If possible, try to create objects outside the loop and reuse them or minimize object creation within the loop. (However, for many applications, object creation inside loops is acceptable and doesn't cause significant performance issues).

    ```java
    // Potentially less efficient: creating new String in each iteration
    for (int i = 0; i < 1000; i++) {
        String message = new String("Iteration: " + i); // New String object created
        System.out.println(message);
    }

    // More efficient (in this specific case): String concatenation might be optimized, or use StringBuilder for more complex cases
    for (int i = 0; i < 1000; i++) {
        String message = "Iteration: " + i; // String concatenation might be optimized by compiler
        System.out.println(message);
    }
    ```

*   **Using efficient data structures for iteration (e.g., `ArrayList` for indexed access, `HashSet` for fast lookups if relevant in the loop logic):**
    The choice of data structure can significantly impact loop performance, especially for operations within the loop body.
    *   **`ArrayList` vs. `LinkedList` for indexed access:** If you need to access elements by index frequently within a loop, `ArrayList` is generally more efficient due to its array-based implementation providing O(1) indexed access. `LinkedList` has O(n) indexed access, which can be slower in loops requiring index-based access.
    *   **`HashSet` for fast lookups:** If your loop involves checking for the existence of elements in a collection (e.g., checking if an element is already processed), using a `HashSet` for lookups can be much faster (average O(1) for `contains()` operation) compared to searching in a `List` (O(n) for linear search).

#### Common looping patterns

Loops are used to implement many common programming patterns:

*   **Summing elements of an array or collection:**

    ```java
    int[] numbers = {1, 2, 3, 4, 5};
    int sum = 0;
    for (int num : numbers) {
        sum += num;
    }
    ```

*   **Finding minimum/maximum element:**

    ```java
    int[] values = {5, 2, 8, 1, 9};
    int min = values[0]; // Initialize min with the first element
    for (int i = 1; i < values.length; i++) {
        if (values[i] < min) {
            min = values[i]; // Update min if a smaller element is found
        }
    }
    ```

*   **Searching for a specific element (linear search):**

    ```java
    int[] data = {10, 20, 30, 40, 50};
    int target = 30;
    int index = -1; // Initialize index to -1 (not found)
    for (int i = 0; i < data.length; i++) {
        if (data[i] == target) {
            index = i;
            break; // Element found, exit loop
        }
    }
    if (index != -1) {
        System.out.println("Target " + target + " found at index " + index);
    } else {
        System.out.println("Target " + target + " not found.");
    }
    ```

*   **Filtering elements based on a condition:**

    ```java
    int[] allNumbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    List<Integer> evenNumbers = new ArrayList<>();
    for (int num : allNumbers) {
        if (num % 2 == 0) {
            evenNumbers.add(num); // Add even numbers to a new list
        }
    }
    System.out.println("Even numbers: " + evenNumbers);
    ```

*   **Counting elements that meet a criteria:**

    ```java
    String[] words = {"apple", "banana", "apricot", "kiwi", "avocado"};
    int countStartsWithA = 0;
    for (String word : words) {
        if (word.startsWith("a") || word.startsWith("A")) {
            countStartsWithA++; // Increment counter if word starts with 'a' or 'A'
        }
    }
    System.out.println("Number of words starting with 'a' or 'A': " + countStartsWithA);
    ```

*   **Iterating and processing data from input streams/files:** (Examples shown earlier in `while` loop section for file and input reading).

#### Scope of variables within loops (loop scope vs. outer scope, variable accessibility)

Remember the scope rules discussed earlier. Variables declared inside a `for` loop's initialization are typically loop-scoped. Variables declared outside have a wider scope. Be mindful of variable visibility and lifetime.

#### Loop invariants (conditions that remain true before and after each iteration - more advanced concept, for loop correctness verification)

Loop invariants are conditions that are true before the loop starts, remain true before each iteration, during each iteration, and after the loop finishes. They are a more advanced concept used for formally reasoning about the correctness of loops and algorithms. Identifying loop invariants can be helpful in designing and verifying complex loops, especially in algorithms where correctness is critical.

#### Looping through Strings (character by character using `charAt()` and loop)

You can iterate through characters of a String using loops and the `charAt(index)` method.

```java
String text = "Hello";
for (int i = 0; i < text.length(); i++) {
    char character = text.charAt(i);
    System.out.println("Character at index " + i + ": " + character);
}

// Enhanced for loop (less direct for String characters, need to convert to char array first if needed)
// String can be converted to char array: text.toCharArray()
for (char ch : text.toCharArray()) {
    System.out.println("Character: " + ch);
}
```

#### Looping with Input/Output Operations (reading multiple lines of input, writing multiple lines of output)

Loops are essential for reading and writing multiple lines of data from/to input streams, files, or consoles. (Examples of file reading and input reading were shown in the `while` loop section).

#### Defensive Looping (adding checks within loops to prevent unexpected errors, like null checks, boundary checks if applicable).

In robust programming, add defensive checks within loops to handle potential errors or unexpected conditions gracefully.

*   **Null checks:** When working with collections or arrays of objects, check for `null` values before accessing object properties or methods to prevent `NullPointerException`.
*   **Boundary checks:** When accessing array elements by index, ensure the index is within valid bounds (0 to length-1) to avoid `ArrayIndexOutOfBoundsException`.
*   **Input validation:** When processing user input or external data, validate the input to ensure it's in the expected format and range to prevent errors during processing.

```java
String[] names = {"Alice", null, "Bob"};
for (String name : names) {
    if (name != null) { // Defensive null check
        System.out.println("Name length: " + name.length());
    } else {
        System.out.println("Null name encountered.");
    }
}

int[] numbers = {1, 2, 3, 4, 5};
int indexToAccess = 7; // Out of bounds index
if (indexToAccess >= 0 && indexToAccess < numbers.length) { // Defensive boundary check
    System.out.println("Value at index " + indexToAccess + ": " + numbers[indexToAccess]);
} else {
    System.out.println("Index out of bounds: " + indexToAccess);
}
```

#### Using `assert` statements within loops (for debugging and validating loop invariants during development).

`assert` statements are useful for debugging and validating assumptions about your code during development. You can use `assert` within loops to check loop invariants or other conditions that should always be true at certain points in the loop. Assertions are typically disabled in production environments for performance reasons.

```java
int sum = 0;
for (int i = 1; i <= 5; i++) {
    sum += i;
    assert sum <= 15 : "Sum should not exceed 15 in this example"; // Loop invariant assertion
    System.out.println("Iteration " + i + ", sum = " + sum);
}
System.out.println("Final sum: " + sum);
```

To enable assertions during runtime, you need to run your Java program with the `-ea` (enable assertions) or `-enableassertions` JVM argument.

#### Recursion vs. Iteration (brief overview of alternatives to loops, trade-offs in terms of readability, stack usage, performance in some scenarios - though recursion isn't strictly a subtopic *of* loops, it's a related concept for repetition).

Recursion and iteration are both ways to achieve repetition in programming.

*   **Iteration (Loops):** Uses loops (`for`, `while`, `do-while`) to repeat a block of code. Iterative solutions are generally more efficient in terms of memory (stack usage) and sometimes performance for simple repetitive tasks.
*   **Recursion:** A function calls itself to solve smaller subproblems. Recursive solutions can be more elegant and readable for problems that have a natural recursive structure (e.g., tree traversals, fractal generation, certain mathematical problems). However, recursion can have higher stack usage (each recursive call adds to the call stack) and might be less efficient in terms of performance for simple repetitive tasks due to function call overhead.

**Trade-offs:**

*   **Readability:** Recursion can sometimes lead to more concise and elegant code, especially for problems naturally defined recursively. Iteration is often more straightforward for simple repetitions.
*   **Stack usage:** Recursion uses the call stack for each recursive call. Deep recursion can lead to stack overflow errors if the call stack limit is exceeded. Iteration typically uses constant stack space (unless you are using data structures that grow with input size).
*   **Performance:** For simple repetitive tasks, iteration is often more performant due to lower overhead. Recursion can have function call overhead. However, for certain algorithms (e.g., divide and conquer), recursion can be more efficient in terms of algorithmic complexity.
*   **Problem suitability:** Some problems are naturally iterative and easier to solve with loops. Others are naturally recursive and more elegantly solved using recursion.

**Example - Factorial calculation:**

*   **Iterative (using loop):**

    ```java
    public static int factorialIterative(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Factorial is not defined for negative numbers");
        }
        int result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
    ```

*   **Recursive:**

    ```java
    public static int factorialRecursive(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Factorial is not defined for negative numbers");
        }
        if (n == 0) {
            return 1; // Base case
        } else {
            return n * factorialRecursive(n - 1); // Recursive step
        }
    }
    ```

In the case of factorial, both iterative and recursive solutions are relatively clear. For very large values of `n`, the iterative version might be slightly more robust against stack overflow issues.

In summary, both loops (iteration) and recursion are important tools for repetition in programming. Choose the approach that best suits the problem at hand, considering readability, performance, stack usage, and problem structure. For many common repetitive tasks, loops are the most straightforward and efficient choice. Recursion is valuable for problems with recursive structure and can lead to more elegant solutions in those cases.

