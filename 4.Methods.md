Certainly! Let's dive deep into the world of Java methods, covering each topic you've listed with comprehensive explanations, examples, and best practices.

## Functions (Methods) in Java: In-Depth Knowledge

**Introduction to Methods**

*   **Definition of a Method:**
    A method in Java is a block of code that performs a specific task. It's a named sequence of statements that can be invoked (called or executed) from other parts of your program. Think of it as a mini-program within your larger program, designed to do one thing well.  Methods are also sometimes referred to as functions or procedures in other programming languages.

*   **Purpose of Methods (Code Reusability, Modularity, Abstraction):**
    *   **Code Reusability:**  This is a primary benefit.  Instead of writing the same code logic multiple times throughout your program, you can encapsulate it within a method and call that method whenever you need to perform that specific task. This significantly reduces code duplication, making your code shorter, easier to read, and maintain.
    *   **Modularity:** Methods promote modularity by breaking down a large, complex program into smaller, manageable, and independent units (the methods).  Each method has a defined responsibility. This modular approach makes it easier to design, develop, test, and debug programs. You can work on individual methods in isolation, and then combine them to create the complete application.
    *   **Abstraction:** Methods provide abstraction by hiding the complex implementation details of a task behind a simple method name and interface (parameters and return type).  When you *use* a method, you don't need to know *how* it works internally. You only need to know *what* it does (its purpose) and *how* to call it (its signature). This simplifies the use of code and allows developers to focus on higher-level logic rather than getting bogged down in implementation specifics.

*   **Method Declaration Syntax:**
    The declaration of a method defines its structure and how it can be accessed and used. The general syntax in Java is:

    ```java
    [access_modifier] [non_access_modifier] return_type method_name(parameter_list) [throws exceptions] {
        // Method body (statements to be executed)
    }
    ```

    Let's break down each component:

    *   **Access Modifiers (public, private, protected, default):**
        Access modifiers control the visibility or accessibility of a method from different parts of your program.
        *   **`public`:**  The method is accessible from *anywhere* - from within the same class, from other classes in the same package, and from classes in different packages. It has the widest scope.
        *   **`private`:** The method is accessible *only* within the class where it is declared. It provides the highest level of encapsulation, hiding implementation details within the class itself.
        *   **`protected`:** The method is accessible within the class itself, within the same package, and by subclasses (even if they are in a different package). It's often used in inheritance to allow subclasses to access methods of the parent class while restricting access from completely unrelated classes.
        *   **`default` (package-private):**  When no access modifier is specified, it's called default or package-private access. The method is accessible within the class itself and within all other classes in the *same package*. It's not accessible from classes in different packages.

        **Example (Access Modifiers):**

        ```java
        public class MyClass {
            public void publicMethod() { // Accessible everywhere
                System.out.println("This is a public method.");
            }

            private void privateMethod() { // Accessible only within MyClass
                System.out.println("This is a private method.");
            }

            protected void protectedMethod() { // Accessible within package and subclasses
                System.out.println("This is a protected method.");
            }

            void defaultMethod() { // Default/package-private access
                System.out.println("This is a default method.");
            }

            public void callPrivateMethod() {
                privateMethod(); // OK: Calling private method from within the same class
            }
        }

        // In another class in the same package:
        class AnotherClassInSamePackage {
            public void testMethods() {
                MyClass obj = new MyClass();
                obj.publicMethod();  // OK
                // obj.privateMethod(); // Error: Cannot access private method
                obj.protectedMethod(); // OK
                obj.defaultMethod();   // OK
            }
        }

        // In a class in a different package:
        // import com.example.mypackage.MyClass; // Assuming MyClass is in package com.example.mypackage

        // class AnotherClassInDifferentPackage {
        //     public void testMethods() {
        //         MyClass obj = new MyClass();
        //         obj.publicMethod();  // OK
        //         // obj.privateMethod(); // Error
        //         // obj.protectedMethod(); // Error (unless subclass)
        //         // obj.defaultMethod();   // Error
        //     }
        // }

        // In a subclass in a different package:
        // import com.example.mypackage.MyClass;

        // class SubclassInDifferentPackage extends MyClass {
        //     public void testMethods() {
        //         publicMethod();  // OK (inherited public)
        //         // privateMethod(); // Error (not inherited)
        //         protectedMethod(); // OK (inherited protected)
        //         // defaultMethod();   // Error (not inherited, different package)
        //     }
        // }
        ```

    *   **Return Type (void, primitive types, reference types):**
        The return type specifies the data type of the value that the method will return after it completes its execution.
        *   **`void`:**  Indicates that the method does *not* return any value. It performs an action but doesn't produce a result that needs to be passed back to the caller.
        *   **Primitive Types (e.g., `int`, `double`, `boolean`, `char`, `byte`, `short`, `long`, `float`):** If the method is designed to calculate and return a single primitive value, you specify the appropriate primitive type as the return type.
        *   **Reference Types (Classes, Interfaces, Arrays, etc.):**  If the method returns an object (an instance of a class), an array, or any other non-primitive type, you specify the class name, interface name, or array type as the return type.

        **Example (Return Types):**

        ```java
        public class ReturnTypeExamples {
            // Method that returns no value (void)
            public void printMessage(String message) {
                System.out.println(message);
                // No return statement needed for void methods (or you can use 'return;' to exit early)
            }

            // Method that returns an integer (primitive type)
            public int add(int a, int b) {
                return a + b; // 'return' keyword is used to send back the result
            }

            // Method that returns a String (reference type)
            public String concatenateStrings(String str1, String str2) {
                return str1 + str2;
            }

            // Method that returns an array of integers
            public int[] createArray(int size) {
                return new int[size];
            }
        }

        class Main {
            public static void main(String[] args) {
                ReturnTypeExamples obj = new ReturnTypeExamples();
                obj.printMessage("Hello!"); // void method call

                int sum = obj.add(5, 3); // int method call, result stored in 'sum'
                System.out.println("Sum: " + sum);

                String combined = obj.concatenateStrings("Hello", " World"); // String method call
                System.out.println("Combined string: " + combined);

                int[] numbers = obj.createArray(5); // int[] method call
                System.out.println("Array length: " + numbers.length);
            }
        }
        ```

    *   **Method Name:**
        The method name is an identifier that you use to call or invoke the method. It should be descriptive and follow Java naming conventions (camelCase, starting with a lowercase letter, verbs are often used). Choose names that clearly indicate what the method does.

        **Example (Method Names):**
        `calculateArea()`, `getUserName()`, `processOrder()`, `isValidInput()`, `sendEmail()`.

    *   **Parameter List:**
        The parameter list is enclosed in parentheses `()` after the method name. It's a comma-separated list of parameters, where each parameter consists of a data type and a parameter name.  Parameters are input values that you pass to the method when you call it.
        *   A method can have zero or more parameters.
        *   If there are no parameters, the parentheses are empty: `()`.

        **Example (Parameter Lists):**

        ```java
        public class ParameterExamples {
            // Method with no parameters
            public void sayHello() {
                System.out.println("Hello!");
            }

            // Method with one parameter (an integer)
            public void printNumber(int number) {
                System.out.println("The number is: " + number);
            }

            // Method with multiple parameters (two strings and a boolean)
            public String createGreeting(String firstName, String lastName, boolean formal) {
                if (formal) {
                    return "Greetings, Mr./Ms. " + lastName;
                } else {
                    return "Hello " + firstName;
                }
            }
        }

        class Main {
            public static void main(String[] args) {
                ParameterExamples obj = new ParameterExamples();
                obj.sayHello(); // No arguments needed

                obj.printNumber(10); // Pass an integer argument

                String greeting1 = obj.createGreeting("Alice", "Smith", true); // Pass three arguments
                String greeting2 = obj.createGreeting("Bob", "Johnson", false);
                System.out.println(greeting1);
                System.out.println(greeting2);
            }
        }
        ```

    *   **Method Signature:**
        The method signature is a crucial concept for method identification and overloading. It consists of:
        *   **Method Name**
        *   **Parameter List (types and order of parameters)**

        **Important:** The return type and access modifiers are *not* part of the method signature.

        Methods in the same class are considered distinct if they have different signatures. This is the basis of method overloading (explained later).

        **Example (Method Signatures):**

        ```java
        public class SignatureExample {
            public int calculate(int a, int b) { // Signature: calculate(int, int)
                return a + b;
            }

            public double calculate(double a, double b) { // Signature: calculate(double, double)
                return a * b;
            }

            public String calculate(String str1, String str2) { // Signature: calculate(String, String)
                return str1 + str2;
            }
        }
        ```
        In this example, we have three methods named `calculate`, but they have different parameter lists (different types of parameters). Therefore, they have different signatures and are considered distinct methods (overloaded methods).

    *   **Method Body:**
        The method body is enclosed in curly braces `{}` after the parameter list. It contains the actual statements (Java code) that will be executed when the method is called. This is where you write the logic to perform the task that the method is designed for.

        **Example (Method Body):**

        ```java
        public class MethodBodyExample {
            public int multiplyAndAdd(int x, int y, int z) {
                int product = x * y; // Statement 1
                int sum = product + z; // Statement 2
                return sum;           // Statement 3
            }
        }
        ```

**Types of Methods**

*   **Predefined Methods (Built-in Library Methods):**
    These are methods that are already written and provided as part of the Java language itself, through its standard class libraries (like the Java Development Kit - JDK). They are ready to use without you having to write their implementation.

    *   **Examples:**
        *   `System.out.println()`:  Prints output to the console (from `java.lang.System` class).
        *   `Math.sqrt(double a)`: Calculates the square root of a number (from `java.lang.Math` class).
        *   `String.length()`: Returns the length of a string (from `java.lang.String` class).
        *   `ArrayList.add(E element)`: Adds an element to an ArrayList (from `java.util.ArrayList` class).
        *   `Integer.parseInt(String s)`: Converts a string to an integer (from `java.lang.Integer` class).

    *   **Purpose:** Predefined methods provide ready-made functionality for common tasks, saving development time and ensuring consistency. They are well-tested and optimized.

    *   **How to Use:** You use predefined methods by calling them on their respective classes or objects, as demonstrated in the examples above. You need to know the class they belong to and their syntax (name, parameters, return type) by referring to Java documentation (like the official Java API documentation).

*   **User-defined Methods (Custom Methods):**
    These are methods that you, the programmer, write yourself to perform specific tasks that are unique to your application or problem domain. They are tailored to your program's requirements.

    *   **Purpose:** To implement custom logic, solve specific problems, and structure your program according to your design.

    *   **How to Create:** You declare and define user-defined methods using the method declaration syntax we discussed earlier. You decide on the method name, parameters, return type, access modifiers, and write the method body with your custom code.

    *   **Example:**

        ```java
        public class CustomMethodsExample {
            // User-defined method to calculate the factorial of a number
            public static long factorial(int n) {
                if (n < 0) {
                    return -1; // Error for negative input
                }
                if (n == 0 || n == 1) {
                    return 1;
                }
                long result = 1;
                for (int i = 2; i <= n; i++) {
                    result *= i;
                }
                return result;
            }

            // User-defined method to check if a number is prime
            public static boolean isPrime(int num) {
                if (num <= 1) {
                    return false;
                }
                for (int i = 2; i <= Math.sqrt(num); i++) {
                    if (num % i == 0) {
                        return false;
                    }
                }
                return true;
            }
        }

        class Main {
            public static void main(String[] args) {
                long fact = CustomMethodsExample.factorial(5);
                System.out.println("Factorial of 5: " + fact);

                boolean prime = CustomMethodsExample.isPrime(17);
                System.out.println("Is 17 prime? " + prime);
            }
        }
        ```

*   **Abstract Methods:**
    Abstract methods are declared in abstract classes or interfaces. They are methods that are declared but do *not* have an implementation (no method body).  They are meant to be overridden (implemented) by subclasses of the abstract class or classes that implement the interface.

    *   **Definition of Abstract Methods:**
        An abstract method is declared using the `abstract` keyword in its method declaration. It ends with a semicolon `;` instead of a method body `{}`.

        ```java
        abstract class MyAbstractClass {
            public abstract void myAbstractMethod(); // Abstract method declaration
        }
        ```

    *   **Abstract Methods in Abstract Classes:**
        Abstract classes can contain both abstract methods and concrete (non-abstract) methods. If a class contains at least one abstract method, the class itself must be declared as `abstract`. You cannot create direct instances (objects) of an abstract class.

        ```java
        abstract class Shape { // Abstract class
            protected String color;

            public Shape(String color) {
                this.color = color;
            }

            public String getColor() {
                return color;
            }

            public abstract double getArea(); // Abstract method - no implementation in Shape
            public abstract double getPerimeter(); // Another abstract method

            public void displayColor() { // Concrete method (non-abstract)
                System.out.println("Color: " + color);
            }
        }

        class Circle extends Shape { // Concrete subclass of abstract class
            private double radius;

            public Circle(String color, double radius) {
                super(color);
                this.radius = radius;
            }

            @Override
            public double getArea() { // Implementation of abstract method from Shape
                return Math.PI * radius * radius;
            }

            @Override
            public double getPerimeter() { // Implementation of another abstract method
                return 2 * Math.PI * radius;
            }
        }

        class Rectangle extends Shape { // Another concrete subclass
            private double width;
            private double height;

            public Rectangle(String color, double width, double height) {
                super(color);
                this.width = width;
                this.height = height;
            }

            @Override
            public double getArea() {
                return width * height;
            }

            @Override
            public double getPerimeter() {
                return 2 * (width + height);
            }
        }

        class Main {
            public static void main(String[] args) {
                // Shape shape = new Shape("Red"); // Error: Cannot instantiate abstract class Shape
                Circle circle = new Circle("Blue", 5); // OK: Instantiate concrete subclass
                Rectangle rect = new Rectangle("Green", 4, 6); // OK

                circle.displayColor();
                System.out.println("Circle Area: " + circle.getArea());
                System.out.println("Circle Perimeter: " + circle.getPerimeter());

                rect.displayColor();
                System.out.println("Rectangle Area: " + rect.getArea());
                System.out.println("Rectangle Perimeter: " + rect.getPerimeter());
            }
        }
        ```

    *   **Abstract Methods in Interfaces:**
        In interfaces (before Java 8), all methods declared in an interface were implicitly abstract and public (no need to use `abstract` keyword explicitly, but it's still abstract). From Java 8 onwards, interfaces can also have default and static methods (which are not abstract, but provide implementations). However, methods declared without `default` or `static` are still abstract by default.

        ```java
        interface Drawable { // Interface
            void draw(); // Abstract method (implicitly public abstract)
            void resize(int newWidth, int newHeight); // Another abstract method
        }

        class CircleShape implements Drawable { // Class implementing the interface
            @Override
            public void draw() {
                System.out.println("Drawing a circle.");
            }

            @Override
            public void resize(int newWidth, int newHeight) {
                System.out.println("Resizing circle to width: " + newWidth + ", height: " + newHeight);
            }
        }

        class SquareShape implements Drawable { // Another class implementing the interface
            @Override
            public void draw() {
                System.out.println("Drawing a square.");
            }

            @Override
            public void resize(int newWidth, int newHeight) {
                System.out.println("Resizing square to width: " + newWidth + ", height: " + newHeight);
            }
        }

        class Main {
            public static void main(String[] args) {
                Drawable circleDrawable = new CircleShape();
                Drawable squareDrawable = new SquareShape();

                circleDrawable.draw();
                circleDrawable.resize(10, 10);

                squareDrawable.draw();
                squareDrawable.resize(8, 8);
            }
        }
        ```

    *   **Purpose of Abstract Methods (Defining Contracts):**
        Abstract methods are used to define a *contract* or a *blueprint* for subclasses or implementing classes. They specify what functionality *must* be provided by any concrete class that extends the abstract class or implements the interface.

        *   **Polymorphism:** Abstract methods are essential for achieving polymorphism. They allow you to treat objects of different concrete classes (subclasses or implementing classes) uniformly through a common abstract type (abstract class or interface). You can call the abstract method, and at runtime, the correct implementation in the specific object's class will be executed.

        *   **Design and Structure:** They help in designing class hierarchies and interfaces, enforcing a certain structure and behavior across related classes.

*   **Final Methods:**
    Final methods are methods that cannot be overridden by subclasses. You declare a method as `final` using the `final` keyword in its method declaration.

    *   **Definition of Final Methods:**

        ```java
        class MyClass {
            public final void myFinalMethod() {
                System.out.println("This is a final method.");
            }
        }
        ```

    *   **Preventing Method Overriding:**
        When a method is declared `final`, any attempt to override it in a subclass will result in a compile-time error. This is a mechanism to prevent subclasses from changing the intended behavior of a method.

        ```java
        class ParentClass {
            public final void importantMethod() {
                System.out.println("This method cannot be overridden.");
            }
        }

        class ChildClass extends ParentClass {
            // @Override // This would cause a compile-time error
            // public void importantMethod() {
            //     System.out.println("Trying to override final method (Error!).");
            // }

            public void anotherMethod() {
                importantMethod(); // OK: Subclass can still call the final method
            }
        }

        class Main {
            public static void main(String[] args) {
                ChildClass child = new ChildClass();
                child.importantMethod(); // Calls the final method from ParentClass
                child.anotherMethod();
            }
        }
        ```

    *   **Use Cases for Final Methods:**
        *   **Preventing Unintended Modification:** When you want to ensure that a method's behavior remains constant and is not altered by subclasses. This can be important for maintaining the integrity of certain functionalities or algorithms.
        *   **Security:** In some cases, you might have methods that perform security-sensitive operations and you want to prevent subclasses from modifying or bypassing these operations.
        *   **Performance Optimization (Historically - Less Relevant Now):** In very early versions of Java, declaring a method as `final` *could* sometimes allow the compiler to perform certain optimizations (like inlining), but with modern JVMs and JIT compilers, this performance benefit is generally negligible and not a primary reason to use `final`.
        *   **Immutability:** When designing immutable classes, you might make methods `final` to ensure that their behavior is consistent and predictable.

*   **Static Factory Methods:**
    Static factory methods are `static` methods within a class that are used to create and return instances of that class. They serve as alternatives to constructors.

    *   **Definition and Purpose of Static Factory Methods (Alternatives to Constructors):**
        Instead of directly using `new ClassName(...)` to create objects, you can use a static method within the class that handles object creation and returns an instance.

        ```java
        public class Point {
            private double x;
            private double y;

            private Point(double x, double y) { // Private constructor
                this.x = x;
                this.y = y;
            }

            // Static factory method to create a Point from Cartesian coordinates
            public static Point fromCartesian(double x, double y) {
                return new Point(x, y);
            }

            // Static factory method to create a Point from polar coordinates (r, theta)
            public static Point fromPolar(double radius, double angle) {
                double x = radius * Math.cos(angle);
                double y = radius * Math.sin(angle);
                return new Point(x, y);
            }

            public double getX() {
                return x;
            }

            public double getY() {
                return y;
            }
        }

        class Main {
            public static void main(String[] args) {
                Point p1 = Point.fromCartesian(3, 4); // Using static factory method
                Point p2 = Point.fromPolar(5, Math.PI / 2); // Another factory method

                System.out.println("Point 1: (" + p1.getX() + ", " + p1.getY() + ")");
                System.out.println("Point 2: (" + p2.getX() + ", " + p2.getY() + ")");

                // Point p3 = new Point(1, 2); // Error: Constructor is private
            }
        }
        ```

    *   **Advantages of Static Factory Methods (Naming, Object Caching, Return Subtypes):**
        *   **Descriptive Naming:** Static factory methods can have more descriptive names than constructors. Constructors are always named the same as the class. Factory methods can have names that clearly indicate *how* an object is being created, making the code more readable and understandable.  Examples: `fromCartesian`, `fromPolar`, `valueOf`, `getInstance`, `create`.
        *   **Object Caching/Pooling:** Factory methods can implement object caching or pooling. They can return pre-existing instances if they are available or create new ones only when necessary. This can be beneficial for performance and resource management, especially for immutable objects or objects that are expensive to create.

            ```java
            public class IntegerCache {
                private static final Integer[] cache = new Integer[256]; // Cache of Integers
                static {
                    for (int i = 0; i < cache.length; i++) {
                        cache[i] = new Integer(i - 128); // Cache Integers from -128 to 127
                    }
                }

                public static Integer valueOf(int i) { // Static factory method for Integer
                    if (i >= -128 && i <= 127) {
                        return cache[i + 128]; // Return from cache if in range
                    } else {
                        return new Integer(i); // Create new Integer if outside cache range
                    }
                }
            }
            ```

        *   **Return Subtypes:** Factory methods can return an object of a subtype of the declared return type. Constructors are limited to returning an instance of the class in which they are defined. This flexibility is useful in situations like creating collections, where you might want to return a specific implementation of an interface (e.g., `List` interface, but return `ArrayList` or `LinkedList` implementation).

            ```java
            public interface List<E> {
                // ... List interface methods ...

                // Static factory method in interface (Java 9+)
                static <E> List<E> of(E... elements) {
                    // Could return ArrayList, LinkedList, or any other List implementation
                    return new ArrayList<>(Arrays.asList(elements));
                }
            }

            class Main {
                public static void main(String[] args) {
                    List<String> names = List.of("Alice", "Bob", "Charlie"); // Factory method returns a List (e.g., ArrayList)
                    System.out.println(names.getClass()); // Output: class java.util.ArrayList
                }
            }
            ```

        *   **Control over Instantiation:** Factory methods give you more control over the object creation process. You can perform additional logic or validation before returning an object. You can also decide to return `null` in certain cases (though this should be used cautiously).

        *   **Hiding Implementation:** By using static factory methods and making constructors private or protected, you can control how objects of your class are created and potentially hide the specific implementation details of object creation.

    *   **Examples of Static Factory Methods (e.g., `valueOf`, `getInstance`):**
        *   `Integer.valueOf(int i)`: Returns an `Integer` instance representing the specified `int` value. It often uses caching for small integer values.
        *   `Boolean.valueOf(boolean b)`: Returns a `Boolean` instance representing the specified boolean value (`true` or `false`). It returns `Boolean.TRUE` or `Boolean.FALSE` (static constants) for efficiency.
        *   `Calendar.getInstance()`: Returns a `Calendar` object, which is an abstract class. The factory method returns a concrete subclass of `Calendar` that is appropriate for the default locale (e.g., `GregorianCalendar`).
        *   `NumberFormat.getInstance()`: Returns a `NumberFormat` object for the default locale.

**Method Parameters (Arguments)**

*   **Formal Parameters:**
    Formal parameters are the variables declared in the method's parameter list in the method declaration. They act as placeholders for the actual values that will be passed into the method when it's called. They define the types and names of the input values the method expects.

    **Example:** In the method declaration `public int add(int a, int b)`, `a` and `b` are formal parameters.

*   **Actual Parameters:**
    Actual parameters (also called arguments) are the actual values that you pass to a method when you call it. These values are assigned to the formal parameters within the method during execution.

    **Example:** When you call `int result = add(5, 3);`, `5` and `3` are actual parameters.

*   **Parameter Passing Mechanisms:**
    Java uses two main mechanisms for passing parameters to methods: pass by value and pass by reference value (for objects).

    *   **Pass by Value:**
        For primitive data types (like `int`, `double`, `boolean`, `char`, etc.), Java uses pass by value. When you pass a primitive variable as an argument, a *copy* of the variable's value is created and passed to the method. Any changes made to the formal parameter inside the method do *not* affect the original variable outside the method.

        ```java
        public class PassByValueExample {
            public static void modifyValue(int num) {
                System.out.println("Inside modifyValue, before modification: " + num);
                num = num + 10; // Modify the formal parameter 'num'
                System.out.println("Inside modifyValue, after modification: " + num);
            }

            public static void main(String[] args) {
                int originalValue = 5;
                System.out.println("Before method call: " + originalValue);
                modifyValue(originalValue); // Pass 'originalValue' as argument
                System.out.println("After method call: " + originalValue); // 'originalValue' remains unchanged
            }
        }
        ```
        **Output:**
        ```
        Before method call: 5
        Inside modifyValue, before modification: 5
        Inside modifyValue, after modification: 15
        After method call: 5
        ```
        As you can see, even though we modified `num` inside `modifyValue`, the `originalValue` in the `main` method remained unchanged because only a *copy* of its value was passed.

    *   **Pass by Reference Value (for Objects):**
        For reference types (objects), Java uses pass by reference value.  When you pass an object reference as an argument, a *copy* of the *reference* (memory address) is passed to the method, not a copy of the object itself. This means that both the original reference and the copied reference in the method point to the *same* object in memory.

        Therefore, if you modify the *state* (fields/attributes) of the object *through* the reference inside the method, those changes *will* be reflected in the original object that was passed as an argument. However, if you reassign the formal parameter reference to point to a *new* object inside the method, it will *not* affect the original reference outside the method (the original reference will still point to the original object).

        ```java
        class Dog {
            String name;

            public Dog(String name) {
                this.name = name;
            }

            public void setName(String newName) {
                this.name = newName;
            }

            public String getName() {
                return name;
            }
        }

        public class PassByReferenceExample {
            public static void modifyDogName(Dog dog) {
                System.out.println("Inside modifyDogName, before modification: " + dog.getName());
                dog.setName("Buddy"); // Modify the object's state through the reference
                System.out.println("Inside modifyDogName, after modification: " + dog.getName());
            }

            public static void changeDogReference(Dog dog) {
                System.out.println("Inside changeDogReference, before reassignment: " + dog.getName());
                dog = new Dog("NewDog"); // Reassign the formal parameter reference to a new object
                System.out.println("Inside changeDogReference, after reassignment: " + dog.getName()); // 'dog' now points to "NewDog" *inside* the method
            }

            public static void main(String[] args) {
                Dog myDog = new Dog("Max");
                System.out.println("Before modifyDogName: " + myDog.getName());
                modifyDogName(myDog); // Pass 'myDog' object reference as argument
                System.out.println("After modifyDogName: " + myDog.getName()); // Name is changed because object state was modified

                System.out.println("\nBefore changeDogReference: " + myDog.getName());
                changeDogReference(myDog); // Pass 'myDog' reference again
                System.out.println("After changeDogReference: " + myDog.getName()); // Name is still "Buddy", reference reassignment inside method didn't affect original
            }
        }
        ```
        **Output:**
        ```
        Before modifyDogName: Max
        Inside modifyDogName, before modification: Max
        Inside modifyDogName, after modification: Buddy
        After modifyDogName: Buddy

        Before changeDogReference: Buddy
        Inside changeDogReference, before reassignment: Buddy
        Inside changeDogReference, after reassignment: Buddy
        After changeDogReference: Buddy
        ```
        *   In `modifyDogName`, we modified the *object's state* (name) using the reference, and this change is reflected in the original `myDog` object.
        *   In `changeDogReference`, we *reassigned* the `dog` formal parameter reference to a new `Dog` object. This reassignment only affects the local reference `dog` *within* the `changeDogReference` method. The original `myDog` reference in `main` still points to the original "Buddy" dog object.

*   **Variable Arguments (Varargs):**
    Varargs (variable arguments) allow you to pass a variable number of arguments of the same type to a method. You declare a vararg parameter using an ellipsis `...` after the parameter type.  Internally, varargs are treated as an array.

    ```java
    public class VarargsExample {
        public static int sum(int... numbers) { // Varargs parameter 'numbers' is treated as int[]
            int total = 0;
            for (int num : numbers) {
                total += num;
            }
            return total;
        }

        public static void main(String[] args) {
            int s1 = sum(1, 2, 3); // Pass 3 arguments
            int s2 = sum(10, 20, 30, 40, 50); // Pass 5 arguments
            int s3 = sum(); // Pass no arguments (empty array)

            System.out.println("Sum 1: " + s1);
            System.out.println("Sum 2: " + s2);
            System.out.println("Sum 3: " + s3);
        }
    }
    ```
    **Output:**
    ```
    Sum 1: 6
    Sum 2: 150
    Sum 3: 0
    ```
    *   A method can have at most one varargs parameter, and if it has one, it must be the last parameter in the parameter list.
    *   Inside the method, the varargs parameter is accessed as an array of the specified type.

*   **Immutable Parameters:**
    Making parameters immutable can improve code readability, predictability, and thread safety.

    *   **Making Parameters `final`:**
        You can declare formal parameters as `final` using the `final` keyword. When a parameter is `final`, you cannot reassign a new value to it within the method body. However, for reference type parameters, it only prevents reassignment of the reference itself, not modification of the object's state (unless the object itself is immutable).

        ```java
        public class FinalParametersExample {
            public static int square(final int num) {
                // num = num * num; // Error: Cannot assign a value to final variable 'num'
                return num * num;
            }

            public static void modifyString(final StringBuilder sb) {
                sb.append(" appended"); // OK: Can modify the state of the object
                // sb = new StringBuilder("new string"); // Error: Cannot reassign final reference 'sb'
            }

            public static void main(String[] args) {
                int number = 5;
                int sq = square(number);
                System.out.println("Square: " + sq);

                StringBuilder text = new StringBuilder("Initial text");
                modifyString(text);
                System.out.println("Modified StringBuilder: " + text);
            }
        }
        ```

    *   **Benefits of Immutable Parameters (Readability, Thread Safety):**
        *   **Readability and Clarity:**  `final` parameters make it clear that the parameter's value should not be changed within the method. This improves code readability and reduces the chances of accidental modification of parameters, making the method's behavior more predictable.
        *   **Thread Safety:** Immutable parameters can contribute to thread safety, especially in multi-threaded environments. If a parameter is `final`, you can be sure that its value will not be changed by another thread while the method is executing, reducing potential race conditions or unexpected side effects. However, for reference type parameters, you also need to ensure that the object itself is thread-safe if it's shared across threads.
        *   **Defensive Programming:** Using `final` parameters can be seen as a form of defensive programming, as it helps prevent unintended changes to parameter values within a method.

*   **Method Chaining (Fluent Interface):**
    Method chaining, also known as a fluent interface, is a design technique where you can call multiple methods on an object in a single line of code, making the code more readable and expressive, especially for object configuration or building complex operations step by step.

    *   **Returning `this` from a Method:**
        To enable method chaining, a method should return a reference to the object on which it was called (i.e., `this`). This allows you to immediately call another method on the returned object.

        ```java
        public class StringBuilderExample {
            private StringBuilder sb;

            public StringBuilderExample() {
                this.sb = new StringBuilder();
            }

            public StringBuilderExample appendString(String str) {
                sb.append(str);
                return this; // Return the current object to enable chaining
            }

            public StringBuilderExample appendNumber(int num) {
                sb.append(num);
                return this;
            }

            public StringBuilderExample appendLine() {
                sb.append("\n");
                return this;
            }

            public String toString() {
                return sb.toString();
            }
        }

        class Main {
            public static void main(String[] args) {
                StringBuilderExample builder = new StringBuilderExample();
                String result = builder
                        .appendString("Hello")
                        .appendString(" ")
                        .appendString("World")
                        .appendNumber(123)
                        .appendLine()
                        .appendString("End of message.")
                        .toString(); // Finally, get the result

                System.out.println(result);
            }
        }
        ```
        **Output:**
        ```
        Hello World123
        End of message.
        ```
        In this example, each `appendString`, `appendNumber`, and `appendLine` method returns `this`, allowing us to chain method calls together.

    *   **Enabling Method Chaining for Object Configuration:**
        Method chaining is particularly useful for configuring objects, setting properties, or building complex objects in a step-by-step manner. It makes the code more declarative and easier to read compared to setting properties individually in multiple lines.

    *   **Examples of Method Chaining in Java APIs (e.g., `StringBuilder`, Streams):**
        *   **`StringBuilder`:** As shown in the example above, `StringBuilder` is a classic example of method chaining in Java. Methods like `append()`, `insert()`, `delete()`, `replace()` return `this`, enabling fluent string manipulation.
        *   **Java Streams API:** Streams heavily utilize method chaining for performing operations on collections of data in a functional style. Methods like `filter()`, `map()`, `sorted()`, `distinct()`, `limit()` return streams, allowing you to chain a sequence of operations.

            ```java
            import java.util.Arrays;
            import java.util.List;
            import java.util.stream.Collectors;

            public class StreamChainingExample {
                public static void main(String[] args) {
                    List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve", "Anna");

                    List<String> filteredAndUppercase = names.stream()
                            .filter(name -> name.startsWith("A")) // Filter names starting with "A"
                            .map(String::toUpperCase) // Convert to uppercase
                            .sorted() // Sort alphabetically
                            .collect(Collectors.toList()); // Collect results into a List

                    System.out.println(filteredAndUppercase); // Output: [ALICE, ANNA]
                }
            }
            ```
        *   **Date/Time APIs (Java 8+):**  Java 8's new Date/Time API (e.g., `LocalDate`, `LocalDateTime`, `ZonedDateTime`) also uses method chaining extensively for date/time manipulation.

            ```java
            import java.time.LocalDate;
            import java.time.format.DateTimeFormatter;

            public class DateTimeChainingExample {
                public static void main(String[] args) {
                    LocalDate today = LocalDate.now();
                    LocalDate futureDate = today
                            .plusMonths(3) // Add 3 months
                            .plusDays(15) // Add 15 days
                            .minusYears(1); // Subtract 1 year

                    System.out.println("Today: " + today.format(DateTimeFormatter.ISO_DATE));
                    System.out.println("Future Date: " + futureDate.format(DateTimeFormatter.ISO_DATE));
                }
            }
            ```

**Method Return Values**

*   **Return Statement:**
    The `return` statement is used within a method to send a value back to the caller of the method. It also terminates the execution of the method at that point.

    *   **Syntax:** `return [expression];`
        *   `expression` is optional, and it's used when the method is designed to return a value. The type of `expression` must match the declared return type of the method.
        *   For `void` methods, you can use `return;` without an expression to exit the method early, or just let the method execute until the end of its body (in which case, there's an implicit return at the end).

*   **Returning Primitive Data Types:**
    Methods can return primitive values like `int`, `double`, `boolean`, `char`, etc. The return type in the method declaration must be one of these primitive types, and the `return` statement must return a value of that type.

    ```java
    public class PrimitiveReturnExample {
        public static int multiply(int a, int b) {
            return a * b; // Return an int value
        }

        public static boolean isEven(int num) {
            return num % 2 == 0; // Return a boolean value
        }

        public static void main(String[] args) {
            int product = multiply(7, 3);
            System.out.println("Product: " + product);

            boolean even = isEven(10);
            System.out.println("Is 10 even? " + even);
        }
    }
    ```

*   **Returning Reference Types (Objects):**
    Methods can return objects (instances of classes), arrays, or other reference types. The return type in the method declaration should be the class name, interface name, or array type, and the `return` statement must return an object of that type (or `null` if allowed by design).

    ```java
    class Person {
        String name;
        int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }
    }

    public class ObjectReturnExample {
        public static Person createPerson(String name, int age) {
            return new Person(name, age); // Return a Person object
        }

        public static int[] generateArray(int size) {
            int[] array = new int[size];
            for (int i = 0; i < size; i++) {
                array[i] = i * 2;
            }
            return array; // Return an int[] array
        }

        public static void main(String[] args) {
            Person p = createPerson("Alice", 30);
            System.out.println("Person: " + p.getName() + ", " + p.getAge());

            int[] numbers = generateArray(5);
            System.out.print("Array: ");
            for (int num : numbers) {
                System.out.print(num + " ");
            }
            System.out.println();
        }
    }
    ```

*   **Returning void:**
    Methods with a `void` return type do not return any value. They perform actions but don't produce a result to be passed back to the caller. You can use `return;` to exit a `void` method early, but it's not required if you want to reach the end of the method body.

    ```java
    public class VoidReturnExample {
        public static void printGreeting(String name) {
            System.out.println("Hello, " + name + "!");
            // No explicit return statement needed here, method execution ends naturally
        }

        public static void processData(int value) {
            if (value < 0) {
                System.out.println("Invalid input. Exiting method.");
                return; // Exit the method early if input is invalid
            }
            System.out.println("Processing data: " + value);
            // ... more processing logic ...
        }

        public static void main(String[] args) {
            printGreeting("Bob");
            processData(25);
            processData(-5); // Method will exit early due to 'return;'
        }
    }
    ```

*   **Returning Multiple Values (Simulating):**
    Java methods can directly return only one value. However, there are several ways to simulate returning multiple values:

    *   **Using Arrays or Collections to Return Multiple Values:**
        You can create an array or a collection (like a `List`, `Set`, `Map`) and put multiple values inside it, then return the array or collection. The caller can then access the individual values from the returned array or collection.

        ```java
        import java.util.Arrays;

        public class ArrayReturnExample {
            public static int[] getMinMax(int[] numbers) {
                if (numbers == null || numbers.length == 0) {
                    return new int[]{}; // Return empty array if input is invalid
                }
                int min = numbers[0];
                int max = numbers[0];
                for (int num : numbers) {
                    if (num < min) {
                        min = num;
                    }
                    if (num > max) {
                        max = num;
                    }
                }
                return new int[]{min, max}; // Return an array containing min and max
            }

            public static void main(String[] args) {
                int[] data = {5, 2, 8, 1, 9, 4};
                int[] minMaxValues = getMinMax(data);
                if (minMaxValues.length == 2) {
                    System.out.println("Minimum: " + minMaxValues[0]);
                    System.out.println("Maximum: " + minMaxValues[1]);
                } else {
                    System.out.println("No valid min/max values returned.");
                }
            }
        }
        ```

    *   **Creating Custom Data Transfer Objects (DTOs) or Records for Return Values:**
        You can define a simple class (DTO - Data Transfer Object) or a record (from Java 14 onwards) to hold multiple related values as fields. Then, the method can return an instance of this DTO or record. This approach provides better type safety and readability compared to using arrays or generic collections, especially when the returned values have different meanings.

        ```java
        // Using a class as DTO
        class MinMaxResult {
            private int min;
            private int max;

            public MinMaxResult(int min, int max) {
                this.min = min;
                this.max = max;
            }

            public int getMin() {
                return min;
            }

            public int getMax() {
                return max;
            }
        }

        public class DtoReturnExample {
            public static MinMaxResult findMinMax(int[] numbers) {
                if (numbers == null || numbers.length == 0) {
                    return null; // Or throw an exception, or return a default MinMaxResult
                }
                int min = numbers[0];
                int max = numbers[0];
                for (int num : numbers) {
                    if (num < min) {
                        min = num;
                    }
                    if (num > max) {
                        max = num;
                    }
                }
                return new MinMaxResult(min, max); // Return a DTO object
            }

            public static void main(String[] args) {
                int[] data = {5, 2, 8, 1, 9, 4};
                MinMaxResult result = findMinMax(data);
                if (result != null) {
                    System.out.println("Minimum: " + result.getMin());
                    System.out.println("Maximum: " + result.getMax());
                } else {
                    System.out.println("No valid min/max result returned.");
                }
            }
        }
        ```

        ```java
        // Using a record (Java 14+)
        record MinMaxRecord(int min, int max) {} // Compact way to define a DTO

        public class RecordReturnExample {
            public static MinMaxRecord getMinMaxRecord(int[] numbers) {
                if (numbers == null || numbers.length == 0) {
                    return null;
                }
                int min = numbers[0];
                int max = numbers[0];
                for (int num : numbers) {
                    if (num < min) {
                        min = num;
                    }
                    if (num > max) {
                        max = num;
                    }
                }
                return new MinMaxRecord(min, max); // Return a record instance
            }

            public static void main(String[] args) {
                int[] data = {5, 2, 8, 1, 9, 4};
                MinMaxRecord record = getMinMaxRecord(data);
                if (record != null) {
                    System.out.println("Minimum: " + record.min()); // Access record components using method names (min(), max())
                    System.out.println("Maximum: " + record.max());
                } else {
                    System.out.println("No valid min/max record returned.");
                }
            }
        }
        ```

    *   **Considerations and Trade-offs:**
        *   **Arrays/Collections:**
            *   **Pros:** Simple to implement, can return a variable number of values of the same type (array) or different types (collection).
            *   **Cons:** Less type-safe (especially with generic collections if not properly parameterized), less descriptive (caller needs to know the order/meaning of elements in the array/collection), can be less readable if returning many values.
        *   **DTOs/Records:**
            *   **Pros:** Type-safe, descriptive field names improve readability, better for returning a fixed set of related values with different meanings, good for encapsulation.
            *   **Cons:** Requires defining a new class or record for each set of return values, might be slightly more verbose in terms of code setup compared to arrays.

        Choosing the best approach depends on the specific scenario, the number of values to return, their types, and the desired level of type safety and code clarity. For a small, fixed number of related values with different meanings, DTOs/records are often preferred for better readability and maintainability. For returning a variable number of values of the same type, or for very simple cases, arrays or collections might be sufficient.

**Method Calling (Invoking Methods)**

*   **Calling a Method:**
    To execute a method, you need to call or invoke it from another part of your program. Method calling involves specifying the method name and providing any required arguments (actual parameters).

*   **Static Methods:**
    Static methods are methods that belong to a class itself, not to any specific instance (object) of the class. They are declared using the `static` keyword.

    *   **Calling Static Methods using Class Name:**
        You call a static method using the class name, followed by the dot `.` operator, and then the method name with parentheses `()` and any arguments.

        ```java
        public class MathUtils {
            public static int square(int number) {
                return number * number;
            }

            public static double calculateCircleArea(double radius) {
                return Math.PI * radius * radius;
            }
        }

        class Main {
            public static void main(String[] args) {
                int sq = MathUtils.square(5); // Call static method using class name
                System.out.println("Square of 5: " + sq);

                double area = MathUtils.calculateCircleArea(3.0); // Call another static method
                System.out.println("Circle Area: " + area);
            }
        }
        ```
        *   You don't need to create an object of the `MathUtils` class to call `square` or `calculateCircleArea` because they are static.

*   **Instance Methods (Non-Static Methods):**
    Instance methods are methods that are associated with specific instances (objects) of a class. They are declared without the `static` keyword.

    *   **Calling Instance Methods using Object Instance:**
        To call an instance method, you first need to create an object of the class using the `new` keyword. Then, you use the object reference, followed by the dot `.` operator, and then the method name with parentheses `()` and any arguments.

        ```java
        class Calculator {
            public int add(int a, int b) {
                return a + b;
            }

            public int subtract(int a, int b) {
                return a - b;
            }
        }

        class Main {
            public static void main(String[] args) {
                Calculator calc = new Calculator(); // Create an instance of Calculator

                int sum = calc.add(10, 5); // Call instance method 'add' on the 'calc' object
                System.out.println("Sum: " + sum);

                int diff = calc.subtract(20, 8); // Call instance method 'subtract' on the same object
                System.out.println("Difference: " + diff);
            }
        }
        ```
        *   You must have an object (`calc` in this case) to call instance methods like `add` and `subtract`.

*   **Method Invocation and the Call Stack:**
    When a method is called in Java (or most programming languages), the execution flow temporarily transfers from the calling code to the method body. The system uses a data structure called the **call stack** to manage method invocations and keep track of where to return to after a method completes.

    *   **Understanding the Call Stack during Method Execution:**
        The call stack is a stack (Last-In, First-Out - LIFO) data structure. When a method is called, a new **stack frame** is created and pushed onto the top of the call stack. This stack frame contains information about the method call, such as:
        *   **Return Address:** The location in the calling code where execution should resume after the method returns.
        *   **Local Variables:** Memory space allocated for the method's local variables and parameters.
        *   **Method Parameters (Arguments):** The values passed as arguments to the method.

        When a method completes its execution (either by reaching a `return` statement or the end of its body), its stack frame is popped off the call stack. The execution then returns to the location specified by the return address in the popped stack frame.

    *   **Stack Frames and Local Variables in the Call Stack:**
        Each method call gets its own stack frame. Local variables declared within a method are stored in its stack frame. These local variables are only accessible within the scope of that method. When the method returns and its stack frame is popped, the local variables are also deallocated (their memory is released).

        **Example (Illustrating Call Stack):**

        ```java
        public class CallStackExample {
            public static void methodA() {
                System.out.println("Method A starts");
                methodB(); // Method A calls Method B
                System.out.println("Method A ends");
            }

            public static void methodB() {
                System.out.println("Method B starts");
                methodC(); // Method B calls Method C
                System.out.println("Method B ends");
            }

            public static void methodC() {
                System.out.println("Method C starts and ends");
            }

            public static void main(String[] args) {
                System.out.println("Main method starts");
                methodA(); // Main method calls Method A
                System.out.println("Main method ends");
            }
        }
        ```
        **Execution flow and Call Stack (simplified):**

        1.  **`main` starts:** Stack: [`main`]
        2.  `main` calls `methodA`: Stack: [`main`, `methodA`]
        3.  `methodA` starts printing.
        4.  `methodA` calls `methodB`: Stack: [`main`, `methodA`, `methodB`]
        5.  `methodB` starts printing.
        6.  `methodB` calls `methodC`: Stack: [`main`, `methodA`, `methodB`, `methodC`]
        7.  `methodC` starts and ends printing.
        8.  `methodC` returns (stack frame popped): Stack: [`main`, `methodA`, `methodB`]
        9.  `methodB` ends printing.
        10. `methodB` returns (stack frame popped): Stack: [`main`, `methodA`]
        11. `methodA` ends printing.
        12. `methodA` returns (stack frame popped): Stack: [`main`]
        13. `main` ends printing.
        14. `main` returns (stack frame popped): Stack: [] (empty)

    *   **Stack Overflow Errors (revisited in context of call stack):**
        A **Stack Overflow Error** occurs when the call stack exceeds its allocated memory limit. This typically happens when there are too many nested method calls, often due to infinite recursion (a method calling itself without a proper base case to stop). Each method call adds a new frame to the stack. If the recursion is deep enough or goes on indefinitely, the stack will run out of space, leading to a stack overflow error.

        ```java
        public class StackOverflowExample {
            public static void recursiveMethod() {
                System.out.println("Recursive call");
                recursiveMethod(); // Method calls itself recursively
            }

            public static void main(String[] args) {
                recursiveMethod(); // Start the infinite recursion
            }
        }
        ```
        Running this program will eventually result in a `StackOverflowError` because `recursiveMethod` keeps calling itself without stopping, continuously pushing frames onto the call stack until it overflows.

**Method Overloading (Function Overloading)**

*   **Definition of Method Overloading:**
    Method overloading is a feature in Java that allows you to define multiple methods in the *same class* with the *same name* but with *different parameter lists*. The methods must differ in either the number of parameters, the types of parameters, or the order of parameter types. The return type is *not* part of method overloading.

*   **Rules for Method Overloading:**
    1.  **Same Method Name:** All overloaded methods must have the same name.
    2.  **Different Parameter Lists:** The parameter lists must be different in at least one of the following ways:
        *   **Number of parameters:** Different number of parameters.
        *   **Types of parameters:** Different data types of parameters.
        *   **Order of parameter types:** Different order of parameter types.
    3.  **Return Type is Not Considered:** The return type of overloaded methods can be the same or different, but it's not used to distinguish between overloaded methods.
    4.  **Access Modifiers and Exceptions are Not Considered:** Access modifiers (e.g., `public`, `private`) and `throws` clauses are not considered for overloading. Overloaded methods can have different access modifiers and `throws` clauses.

*   **Return Type in Method Overloading:**
    As mentioned, the return type is *not* part of the method signature and is not used to differentiate overloaded methods. You can have overloaded methods with the same name and different parameter lists that return different types, or the same type.

*   **Benefits of Method Overloading:**
    *   **Code Reusability and Readability:** Method overloading enhances code reusability and readability. You can use the same method name for operations that are conceptually similar but operate on different types of data or with different numbers of inputs. This makes the code more intuitive and easier to understand.
    *   **Flexibility:** It provides flexibility in how you can call a method. You can choose the version of the method that best suits the types and number of arguments you have available.
    *   **Polymorphism (Compile-time Polymorphism or Static Polymorphism):** Method overloading is an example of compile-time polymorphism. The compiler decides which overloaded method to call based on the types and number of arguments provided at the time of method invocation. This decision is made at compile time, hence "compile-time polymorphism."

*   **Constructor Overloading:**
    Constructors can also be overloaded in Java, following the same rules as method overloading. You can have multiple constructors in a class with the same name (the class name) but different parameter lists. This allows you to create objects of the class in different ways, with different initializations based on the arguments you provide to the constructor.

    **Example (Method Overloading and Constructor Overloading):**

    ```java
    public class Calculator {
        // Method Overloading
        public int add(int a, int b) {
            System.out.println("Adding two integers");
            return a + b;
        }

        public double add(double a, double b) {
            System.out.println("Adding two doubles");
            return a + b;
        }

        public int add(int a, int b, int c) {
            System.out.println("Adding three integers");
            return a + b + c;
        }

        public String add(String str1, String str2) {
            System.out.println("Concatenating two strings");
            return str1 + str2;
        }

        // Constructor Overloading
        public Calculator() { // No-argument constructor
            System.out.println("Calculator object created with default constructor.");
        }

        public Calculator(int initialValue) { // Constructor with one integer argument
            System.out.println("Calculator object created with initial value: " + initialValue);
        }

        public Calculator(double initialValue) { // Constructor with one double argument
            System.out.println("Calculator object created with initial double value: " + initialValue);
        }
    }

    class Main {
        public static void main(String[] args) {
            Calculator calc = new Calculator(); // Calls no-argument constructor
            Calculator calc2 = new Calculator(10); // Calls constructor with int argument
            Calculator calc3 = new Calculator(3.14); // Calls constructor with double argument

            int sum1 = calc.add(5, 3); // Calls add(int, int)
            System.out.println("Sum1: " + sum1);

            double sum2 = calc.add(2.5, 3.5); // Calls add(double, double)
            System.out.println("Sum2: " + sum2);

            int sum3 = calc.add(1, 2, 3); // Calls add(int, int, int)
            System.out.println("Sum3: " + sum3);

            String combined = calc.add("Hello", " World"); // Calls add(String, String)
            System.out.println("Combined: " + combined);
        }
    }
    ```
    In this example, the `Calculator` class has overloaded `add` methods and overloaded constructors, demonstrating both method and constructor overloading. The compiler determines which method or constructor to call based on the arguments provided during invocation.

**Method Overriding (Function Overriding)**

*   **Definition of Method Overriding:**
    Method overriding is a feature in object-oriented programming that allows a subclass to provide a *specific implementation* for a method that is already defined in its superclass (parent class). Overriding happens in the context of inheritance.

*   **Rules for Method Overriding:**
    1.  **Same Method Signature:** The overriding method in the subclass must have the *same signature* (method name and parameter list) as the method in the superclass that it is overriding.
    2.  **Same or More Permissive Access Modifier:** The access modifier of the overriding method in the subclass must be the same as or more permissive than the access modifier of the overridden method in the superclass. For example, if the superclass method is `protected`, the subclass method can be `protected` or `public`, but not `private` or `default` (package-private). You cannot make an overriding method less accessible than the overridden method.
    3.  **Same Return Type (or Covariant Return Type - explained later):**  In most cases, the return type of the overriding method must be the same as the return type of the overridden method. However, Java 5 introduced covariant return types, which allow the overriding method to have a more specific return type (a subtype of the superclass method's return type).
    4.  **`@Override` Annotation (Optional but Recommended):** It's good practice to use the `@Override` annotation above the overriding method in the subclass. This annotation is not mandatory for overriding to work, but it serves as a signal to the compiler and to other developers that this method is intended to override a superclass method. If you use `@Override` and the method does not actually override a method from the superclass (e.g., due to a typo in the method signature), the compiler will give a compile-time error, helping you catch mistakes early.
    5.  **`final` and `static` Methods Cannot Be Overridden:** `final` methods cannot be overridden. `static` methods cannot be overridden either; although a subclass can declare a static method with the same signature as a static method in the superclass, this is called method hiding, not method overriding. Overriding is related to instance methods and runtime polymorphism.
    6.  **Exceptions (Checked Exceptions):** If the overridden method in the superclass declares that it throws checked exceptions, the overriding method in the subclass can throw the same checked exceptions, or subclasses of those exceptions, or no checked exceptions at all. It cannot throw new or broader checked exceptions that are not declared in the superclass method's `throws` clause. Unchecked exceptions (like `RuntimeException`) are not subject to this restriction.

*   **Method Overriding in Inheritance:**
    Method overriding is a key concept in inheritance and polymorphism. It allows subclasses to specialize or customize the behavior of methods inherited from their superclasses.

*   **`@Override` Annotation:**
    Using the `@Override` annotation is highly recommended when you intend to override a method. It provides compile-time checking. If you misspell the method name or have a different parameter list, the compiler will detect that it's not a valid override and give an error. This helps prevent subtle bugs and makes your code more robust.

*   **Runtime Polymorphism through Method Overriding:**
    Method overriding is the mechanism that enables runtime polymorphism (or dynamic polymorphism). Polymorphism means "many forms." In the context of method overriding, it means that when you call an overridden method on an object reference, the actual method implementation that gets executed is determined at *runtime* based on the *actual type* (class) of the object, not the type of the reference variable.

    **Example (Method Overriding and Runtime Polymorphism):**

    ```java
    class Animal {
        public void makeSound() {
            System.out.println("Generic animal sound");
        }
    }

    class Dog extends Animal {
        @Override // Indicate that this method is overriding a superclass method
        public void makeSound() {
            System.out.println("Woof!"); // Dog-specific implementation
        }
    }

    class Cat extends Animal {
        @Override
        public void makeSound() {
            System.out.println("Meow!"); // Cat-specific implementation
        }
    }

    public class PolymorphismExample {
        public static void animalSound(Animal animal) {
            animal.makeSound(); // Polymorphic method call
        }

        public static void main(String[] args) {
            Animal animal = new Animal();
            Dog dog = new Dog();
            Cat cat = new Cat();

            animalSound(animal); // Calls Animal's makeSound()
            animalSound(dog);    // Calls Dog's makeSound() (overridden)
            animalSound(cat);    // Calls Cat's makeSound() (overridden)

            Animal animalRefDog = new Dog(); // Animal reference pointing to a Dog object
            Animal animalRefCat = new Cat(); // Animal reference pointing to a Cat object

            animalRefDog.makeSound(); // Still calls Dog's makeSound() (runtime polymorphism)
            animalRefCat.makeSound(); // Still calls Cat's makeSound()
        }
    }
    ```
    **Output:**
    ```
    Generic animal sound
    Woof!
    Meow!
    Woof!
    Meow!
    ```
    *   In `animalSound(Animal animal)`, the parameter type is `Animal`. However, when we pass a `Dog` object or a `Cat` object to this method, the *overridden* `makeSound()` method of `Dog` or `Cat` is executed, not the `makeSound()` method of `Animal`. This is runtime polymorphism. The decision of which `makeSound()` method to call is made at runtime based on the actual type of the object being referenced by `animal`.

*   **Method Overriding vs. Method Overloading:**

    | Feature           | Method Overriding                                  | Method Overloading                                  |
    | ----------------- | -------------------------------------------------- | -------------------------------------------------- |
    | **Relationship**  | Between a superclass and a subclass (inheritance) | Within the same class                               |
    | **Method Name**   | Same name in superclass and subclass               | Same name in the same class                         |
    | **Parameter List**| Same parameter list in superclass and subclass       | Different parameter lists (number, types, or order) |
    | **Return Type**   | Same (or covariant)                               | Can be same or different                            |
    | **Access Modifier**| Same or more permissive in subclass                | Can be same or different                            |
    | **Purpose**       | To provide a specific implementation in subclass   | To provide multiple methods with similar names     |
    | **Polymorphism**  | Runtime polymorphism (dynamic)                     | Compile-time polymorphism (static)                   |
    | **Context**       | Inheritance, dynamic method dispatch               | Within a class, method selection at compile time   |

*   **Covariant Return Types:**
    Covariant return types (introduced in Java 5) allow an overriding method in a subclass to have a more specific return type than the overridden method in the superclass, as long as the return type in the subclass is a subtype of the return type in the superclass.

    *   **Definition and Purpose of Covariant Return Types:**
        Before covariant return types, the return type of an overriding method had to be exactly the same as the overridden method's return type. Covariant return types relax this restriction slightly, allowing for more flexibility while maintaining type safety.

    *   **Returning Subtypes in Overriding Methods:**

        ```java
        class Animal {
            public Animal createOffspring() { // Returns Animal
                System.out.println("Animal creates a generic offspring.");
                return new Animal();
            }
        }

        class Dog extends Animal {
            @Override
            public Dog createOffspring() { // Returns Dog (subtype of Animal) - Covariant return type
                System.out.println("Dog creates a dog offspring.");
                return new Dog();
            }
        }

        class Cat extends Animal {
            @Override
            public Cat createOffspring() { // Returns Cat (subtype of Animal) - Covariant return type
                System.out.println("Cat creates a cat offspring.");
                return new Cat();
            }
        }

        public class CovariantReturnExample {
            public static void main(String[] args) {
                Animal animal = new Animal();
                Dog dog = new Dog();
                Cat cat = new Cat();

                Animal animalOffspring = animal.createOffspring(); // Returns Animal
                Dog dogOffspring = dog.createOffspring();         // Returns Dog (more specific type)
                Cat catOffspring = cat.createOffspring();         // Returns Cat (more specific type)

                System.out.println("Animal offspring type: " + animalOffspring.getClass().getSimpleName());
                System.out.println("Dog offspring type: " + dogOffspring.getClass().getSimpleName());
                System.out.println("Cat offspring type: " + catOffspring.getClass().getSimpleName());
            }
        }
        ```
        **Output:**
        ```
        Animal creates a generic offspring.
        Dog creates a dog offspring.
        Cat creates a cat offspring.
        Animal offspring type: Animal
        Dog offspring type: Dog
        Cat offspring type: Cat
        ```
        *   In `Animal.createOffspring()`, the return type is `Animal`. In `Dog.createOffspring()` and `Cat.createOffspring()`, the return types are `Dog` and `Cat` respectively, which are subtypes of `Animal`. This is allowed due to covariant return types.
        *   Covariant return types are useful when you want to provide more specific return types in subclass methods without violating the Liskov Substitution Principle (a principle of object-oriented design that states that subtypes should be substitutable for their base types without altering the correctness of the program).

**Recursion**

*   **Definition of Recursion:**
    Recursion is a programming technique where a method calls itself directly or indirectly. A recursive method solves a problem by breaking it down into smaller, self-similar subproblems.

*   **Recursive Methods:**
    A recursive method is a method that includes a call to itself within its own method body.

*   **Base Case:**
    Every recursive method must have one or more **base cases** (also called stopping conditions). A base case is a condition under which the recursion stops, and the method returns a result directly without making further recursive calls. Without a base case, recursion would continue infinitely, leading to a stack overflow error.

*   **Recursive Step:**
    The **recursive step** is the part of the method where it calls itself to solve a smaller subproblem. In each recursive step, the problem should be reduced in size, moving closer to the base case.

*   **Stack Overflow Error (in Recursion Context):**
    If a recursive method does not have a proper base case or if the problem is not reduced towards the base case in each step, the recursion may never stop. This will lead to an excessive number of nested method calls, causing the call stack to overflow, resulting in a `StackOverflowError`.

*   **Examples of Recursion:**
    *   **Factorial Calculation:**

        ```java
        public class RecursionFactorial {
            public static long factorialRecursive(int n) {
                if (n == 0) { // Base case: factorial of 0 is 1
                    return 1;
                } else if (n < 0) { // Error case
                    return -1; // Or throw an exception for invalid input
                } else {
                    // Recursive step: n! = n * (n-1)!
                    return n * factorialRecursive(n - 1);
                }
            }

            public static void main(String[] args) {
                System.out.println("Factorial of 5 (recursive): " + factorialRecursive(5));
                System.out.println("Factorial of 0 (recursive): " + factorialRecursive(0));
                System.out.println("Factorial of -1 (recursive): " + factorialRecursive(-1)); // Error case
            }
        }
        ```
        **How it works (factorialRecursive(5)):**
        1.  `factorialRecursive(5)` calls `5 * factorialRecursive(4)`
        2.  `factorialRecursive(4)` calls `4 * factorialRecursive(3)`
        3.  `factorialRecursive(3)` calls `3 * factorialRecursive(2)`
        4.  `factorialRecursive(2)` calls `2 * factorialRecursive(1)`
        5.  `factorialRecursive(1)` calls `1 * factorialRecursive(0)`
        6.  `factorialRecursive(0)` reaches base case, returns `1`
        7.  `factorialRecursive(1)` returns `1 * 1 = 1`
        8.  `factorialRecursive(2)` returns `2 * 1 = 2`
        9.  `factorialRecursive(3)` returns `3 * 2 = 6`
        10. `factorialRecursive(4)` returns `4 * 6 = 24`
        11. `factorialRecursive(5)` returns `5 * 24 = 120`

    *   **Fibonacci Sequence:**

        ```java
        public class RecursionFibonacci {
            public static int fibonacciRecursive(int n) {
                if (n <= 1) { // Base cases: fib(0)=0, fib(1)=1
                    return n;
                } else {
                    // Recursive step: fib(n) = fib(n-1) + fib(n-2)
                    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
                }
            }

            public static void main(String[] args) {
                System.out.println("Fibonacci(10) (recursive): " + fibonacciRecursive(10));
                System.out.println("Fibonacci(0) (recursive): " + fibonacciRecursive(0));
                System.out.println("Fibonacci(1) (recursive): " + fibonacciRecursive(1));
            }
        }
        ```

*   **Advantages and Disadvantages of Recursion:**
    *   **Advantages:**
        *   **Elegance and Simplicity:** For certain problems, recursive solutions can be more elegant, concise, and easier to understand compared to iterative solutions, especially for problems that have a naturally recursive structure (like tree traversals, divide and conquer algorithms).
        *   **Problem Decomposition:** Recursion naturally breaks down complex problems into smaller, self-similar subproblems, which can simplify problem-solving and algorithm design.
    *   **Disadvantages:**
        *   **Performance Overhead:** Recursive method calls involve function call overhead (creating stack frames, pushing and popping from the call stack). For problems that can be solved iteratively, recursion is often less efficient in terms of execution time and memory usage due to this overhead.
        *   **Stack Overflow Risk:** Deep recursion can lead to stack overflow errors if the recursion depth exceeds the call stack limit. This is a practical limitation, especially for problems that require very deep recursion.
        *   **Debugging Complexity:** Debugging recursive methods can sometimes be more challenging than debugging iterative methods, especially when dealing with complex recursive structures or base cases.

*   **Tail Recursion (and Java's limitations):**
    Tail recursion is a special form of recursion where the recursive call is the very last operation in the method. In tail-recursive methods, after the recursive call returns, there are no further computations to be done in the current method.

    *   **Concept of Tail Recursion Optimization:**
        In programming languages that support tail recursion optimization, the compiler or runtime environment can optimize tail-recursive calls to be as efficient as iteration. Instead of creating a new stack frame for each recursive call, it can reuse the current stack frame, effectively turning the recursion into a loop. This optimization prevents stack overflow errors and improves performance for tail-recursive functions.

    *   **Java's Lack of Tail Recursion Optimization (in most cases):**
        **Java, in general, does not perform tail recursion optimization** in most standard JVM implementations. While some JVMs *might* perform limited tail call optimization in very specific scenarios, it's not a guaranteed or reliable optimization in Java. Therefore, in Java, deep recursion can still lead to stack overflow errors, even if the recursion is tail-recursive in form.

        **Example (Tail-Recursive Factorial - in concept, not optimized in Java):**

        ```java
        public class TailRecursionFactorial {
            public static long factorialTailRecursive(int n, long accumulator) {
                if (n == 0) { // Base case
                    return accumulator;
                } else if (n < 0) {
                    return -1; // Error case
                } else {
                    // Tail-recursive call: recursive call is the last operation
                    return factorialTailRecursive(n - 1, n * accumulator);
                }
            }

            // Initial call to start tail recursion
            public static long factorial(int n) {
                return factorialTailRecursive(n, 1);
            }

            public static void main(String[] args) {
                System.out.println("Factorial of 5 (tail recursive): " + factorial(5));
                System.out.println("Factorial of 0 (tail recursive): " + factorial(0));
                System.out.println("Factorial of -1 (tail recursive): " + factorial(-1));
            }
        }
        ```
        In `factorialTailRecursive`, the recursive call is `return factorialTailRecursive(n - 1, n * accumulator);`, which is the last operation. However, even though it's tail-recursive in form, Java's JVM usually won't optimize it to avoid stack overflow for very large inputs.

    *   **Implications for Deep Recursion in Java:**
        Due to Java's lack of reliable tail recursion optimization, when you are dealing with problems that might lead to deep recursion in Java, it's generally safer and more efficient to consider iterative solutions (using loops) rather than relying on recursion, especially if stack overflow is a potential concern. For problems that are naturally recursive but might be deep, you could also explore techniques like memoization or dynamic programming to optimize performance and avoid excessive recursion depth.

**Method Scope and Lifetime**

*   **Scope of Variables within Methods (Local Variables):**
    The scope of a variable in Java refers to the region of the program where that variable can be accessed and used. Variables declared inside a method are called **local variables**. Their scope is limited to the method in which they are declared. They are only visible and accessible within that method's body.

    ```java
    public class ScopeExample {
        public static void myMethod() {
            int localVar = 10; // Local variable 'localVar' is declared in myMethod
            System.out.println("Inside myMethod, localVar: " + localVar); // OK: Access within scope
        }

        public static void anotherMethod() {
            // System.out.println("Inside anotherMethod, localVar: " + localVar); // Error: 'localVar' is out of scope
        }

        public static void main(String[] args) {
            myMethod();
            // System.out.println("In main method, localVar: " + localVar); // Error: 'localVar' is out of scope
        }
    }
    ```
    *   `localVar` is declared inside `myMethod`. It's only accessible within `myMethod`. Trying to access it in `anotherMethod` or `main` method will result in a compile-time error because it's out of scope.

*   **Lifetime of Local Variables:**
    The lifetime of a local variable is tied to the execution of the method in which it is declared. When a method is called, local variables are created and allocated memory in the method's stack frame. When the method completes its execution and returns, the stack frame is popped, and the local variables are automatically deallocated (their memory is released). They cease to exist once the method execution is finished.

*   **Method Scope and Access Modifiers:**
    Access modifiers (`public`, `private`, `protected`, default) primarily control the visibility and accessibility of methods (and class members like fields). They define from where and which parts of the program a method can be called.

    *   **Impact of Access Modifiers on Method Visibility:**
        *   `public`: Method is visible and accessible from anywhere.
        *   `protected`: Visible within the package and in subclasses (even in different packages).
        *   `default` (package-private): Visible only within the same package.
        *   `private`: Visible only within the class itself.

        The access modifier determines the scope of the method's *visibility* from outside the class or package, but it doesn't directly affect the scope of local variables *inside* the method itself. Local variables are always method-scoped, regardless of the method's access modifier.

*   **Variable Scope Beyond Local Variables:**
    While local variables have method scope, there are other types of variables with broader scopes in Java:

    *   **Instance Variables and Method Access:**
        Instance variables (also called fields or attributes) are declared within a class but outside of any method, constructor, or block, and they are not `static`. Each object (instance) of the class gets its own copy of instance variables. Instance variables have object scope. They are accessible from within *all* instance methods of the class.

        ```java
        public class Car {
            String model; // Instance variable
            String color; // Instance variable

            public Car(String model, String color) {
                this.model = model;
                this.color = color;
            }

            public void displayDetails() {
                System.out.println("Model: " + model); // Accessing instance variable 'model'
                System.out.println("Color: " + color); // Accessing instance variable 'color'
            }

            public void changeColor(String newColor) {
                color = newColor; // Modifying instance variable 'color'
            }
        }
        ```
        Instance variables `model` and `color` are declared at the class level. They are accessible in `displayDetails` and `changeColor` instance methods.

    *   **Class Variables (Static Variables) and Method Access:**
        Class variables (static variables) are declared with the `static` keyword within a class, outside of any method, constructor, or block. There is only one copy of a class variable shared among all objects of the class and the class itself. Class variables have class scope. They are accessible from within *all* methods (static and instance) of the class, and they can also be accessed directly using the class name (e.g., `ClassName.staticVariable`).

        ```java
        public class Counter {
            static int count = 0; // Class variable (static variable)

            public Counter() {
                count++; // Increment class variable 'count' each time an object is created
            }

            public static int getCount() {
                return count; // Accessing class variable 'count' from a static method
            }

            public void displayCount() {
                System.out.println("Current count: " + count); // Accessing class variable 'count' from an instance method
            }
        }

        class Main {
            public static void main(String[] args) {
                Counter c1 = new Counter();
                Counter c2 = new Counter();
                Counter c3 = new Counter();

                System.out.println("Total objects created: " + Counter.getCount()); // Accessing class variable using class name
                c1.displayCount(); // Accessing class variable from instance method
                c2.displayCount();
                c3.displayCount();
            }
        }
        ```
        `count` is a class variable. It's shared by all `Counter` objects. Both `getCount` (static method) and `displayCount` (instance method) can access it. You can also access it using `Counter.count` (though directly accessing static variables like this from outside the class is often discouraged for better encapsulation).

**Functional Programming Concepts related to Methods**

*   **Lambda Expressions (Anonymous Functions):**
    Lambda expressions, introduced in Java 8, are a concise way to represent anonymous functions (functions without a name). They allow you to treat functionality as method arguments, return values, or assign them to variables. Lambda expressions are particularly useful for functional programming and working with collections and streams.

    *   **Introduction to Lambda Expressions:**
        Lambda expressions provide a more compact syntax for defining functional interfaces (interfaces with a single abstract method). They are essentially shorthand for creating instances of anonymous inner classes that implement functional interfaces.

    *   **Syntax of Lambda Expressions:**
        The basic syntax of a lambda expression is:

        ```
        (parameter list) -> { lambda body }
        ```
        *   `(parameter list)`: A comma-separated list of input parameters, similar to method parameters. You can optionally specify parameter types or let the compiler infer them. If there's only one parameter, parentheses are optional. If there are no parameters, use `()`.
        *   `->`: The arrow token, separating the parameter list from the lambda body.
        *   `{ lambda body }`: The code to be executed when the lambda expression is invoked. It's similar to a method body. If the body is a single expression, you can omit the curly braces and the `return` keyword (for methods that return a value).

    *   **Functional Interfaces:**
        Lambda expressions are used in conjunction with functional interfaces. A functional interface is an interface that has exactly *one* abstract method. Examples in the Java standard library include `Runnable`, `Comparator`, `Predicate`, `Function`, `Consumer`, `Supplier`, etc.

    *   **Lambda Expressions with Collections and Streams:**
        Lambda expressions are heavily used with Java Collections and the Streams API to perform functional operations on collections of data.

        **Example (Lambda Expressions):**

        ```java
        import java.util.Arrays;
        import java.util.List;
        import java.util.function.Predicate;
        import java.util.stream.Collectors;

        public class LambdaExample {
            public static void main(String[] args) {
                // Example 1: Lambda as Runnable (for threads)
                Runnable runnableTask = () -> { // Lambda expression for Runnable interface
                    System.out.println("Running in a separate thread using lambda.");
                };
                new Thread(runnableTask).start();

                // Example 2: Lambda as Comparator (for sorting)
                List<String> names = Arrays.asList("Charlie", "Alice", "Bob", "David");
                names.sort((s1, s2) -> s1.compareTo(s2)); // Lambda for Comparator<String>
                System.out.println("Sorted names: " + names);

                // Example 3: Lambda with Streams API (filtering, mapping)
                List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
                List<Integer> evenNumbers = numbers.stream()
                        .filter(n -> n % 2 == 0) // Lambda as Predicate<Integer> (filter even numbers)
                        .map(n -> n * 2) // Lambda as Function<Integer, Integer> (map to double)
                        .collect(Collectors.toList());
                System.out.println("Even numbers doubled: " + evenNumbers);

                // Example 4: Lambda with Predicate (custom filter)
                Predicate<String> isLongName = name -> name.length() > 4; // Lambda as Predicate<String>
                List<String> longNames = names.stream()
                        .filter(isLongName) // Use the Predicate<String> lambda
                        .collect(Collectors.toList());
                System.out.println("Long names: " + longNames);
            }
        }
        ```
        *   **`Runnable` example:** `() -> { ... }` is a lambda expression that implements the `Runnable` interface (which has a single abstract method `run()`).
        *   **`Comparator` example:** `(s1, s2) -> s1.compareTo(s2)` is a lambda expression that implements the `Comparator<String>` interface (method `compare(String o1, String o2)`).
        *   **Streams API examples:** Lambdas are used as arguments to stream operations like `filter` (which takes a `Predicate`), `map` (which takes a `Function`), etc.

*   **Method References:**
    Method references are a shorthand syntax for lambda expressions when the lambda expression simply calls an existing method. They provide an even more concise way to represent functional interfaces in certain cases.

    *   **Introduction to Method References:**
        Method references allow you to refer to methods by their names without invoking them directly. They are used when a lambda expression's body is just calling a method that already exists.

    *   **Types of Method References:**
        There are four types of method references:
        1.  **Static Method Reference:** `ClassName::staticMethodName` (e.g., `Math::sqrt`) - Refers to a static method of a class.
        2.  **Instance Method Reference of a Particular Object:** `objectReference::instanceMethodName` (e.g., `System.out::println`) - Refers to an instance method of a specific object.
        3.  **Instance Method Reference of an Arbitrary Object of a Particular Type:** `ClassName::instanceMethodName` (e.g., `String::length`) - Refers to an instance method of objects of a particular class. The object on which the method will be called becomes the first parameter of the functional interface method.
        4.  **Constructor Reference:** `ClassName::new` (e.g., `ArrayList::new`) - Refers to a constructor of a class.

    *   **Using Method References for concise code:**
        Method references can make code more readable and concise when lambda expressions are simply delegating to existing methods.

        **Example (Method References):**

        ```java
        import java.util.Arrays;
        import java.util.List;
        import java.util.function.Function;
        import java.util.stream.Collectors;

        public class MethodReferenceExample {
            public static int stringLength(String s) { // Static method
                return s.length();
            }

            public static void main(String[] args) {
                List<String> names = Arrays.asList("Charlie", "Alice", "Bob", "David");

                // 1. Static Method Reference: Math::sqrt (example, not directly applicable here)
                // Function<Double, Double> sqrtFunc = Math::sqrt;
                // System.out.println("Square root of 25: " + sqrtFunc.apply(25.0));

                // 2. Instance Method Reference of a Particular Object: System.out::println
                names.forEach(System.out::println); // Method reference to System.out.println

                // 3. Instance Method Reference of an Arbitrary Object of a Particular Type: String::length
                List<Integer> nameLengths = names.stream()
                        .map(String::length) // Method reference to String.length()
                        .collect(Collectors.toList());
                System.out.println("Name lengths: " + nameLengths);

                // 4. Constructor Reference: ArrayList::new (example, not directly used here)
                // Supplier<List<String>> listSupplier = ArrayList::new;
                // List<String> newList = listSupplier.get();

                // Using a static method reference to calculate string length
                List<Integer> nameLengths2 = names.stream()
                        .map(MethodReferenceExample::stringLength) // Static method reference
                        .collect(Collectors.toList());
                System.out.println("Name lengths (using static method ref): " + nameLengths2);

                // Using lambda expression instead of method reference (for comparison)
                List<Integer> nameLengthsLambda = names.stream()
                        .map(s -> s.length()) // Equivalent lambda expression
                        .collect(Collectors.toList());
                System.out.println("Name lengths (using lambda): " + nameLengthsLambda);
            }
        }
        ```
        *   `System.out::println`: Instance method reference of a particular object (`System.out`) to the `println` method.
        *   `String::length`: Instance method reference of an arbitrary object of type `String` to the `length` method.
        *   `MethodReferenceExample::stringLength`: Static method reference to the static method `stringLength` of the `MethodReferenceExample` class.
        *   The lambda expression `s -> s.length()` is equivalent to the method reference `String::length`, but the method reference is often considered more concise and readable when it's applicable.

*   **Higher-Order Functions (Methods as Parameters and Return Values):**
    In functional programming, higher-order functions are functions that can:
    1.  Take other functions as arguments.
    2.  Return functions as results.
    Java, with lambda expressions and method references, supports the concept of higher-order functions. Functional interfaces are used as types for parameters and return values that are functions (or behaviors).

    *   **Methods Accepting Functional Interfaces as Parameters:**
        Methods can be designed to accept functional interfaces as parameters. This allows you to pass behavior or logic as arguments to methods.

        ```java
        import java.util.Arrays;
        import java.util.List;
        import java.util.function.Predicate;
        import java.util.stream.Collectors;

        public class HigherOrderFunctionExample {
            // Method that takes a List<T> and a Predicate<T> as parameters
            public static <T> List<T> filterList(List<T> list, Predicate<T> condition) {
                return list.stream()
                        .filter(condition) // Apply the Predicate condition
                        .collect(Collectors.toList());
            }

            public static void main(String[] args) {
                List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

                // Using a lambda expression as Predicate
                Predicate<Integer> isEven = n -> n % 2 == 0;
                List<Integer> evenNums = filterList(numbers, isEven);
                System.out.println("Even numbers: " + evenNums);

                // Using another lambda expression for a different condition
                Predicate<Integer> isGreaterThan5 = n -> n > 5;
                List<Integer> greaterThan5Nums = filterList(numbers, isGreaterThan5);
                System.out.println("Numbers > 5: " + greaterThan5Nums);

                // Using an anonymous inner class (pre-Java 8 way, for comparison)
                List<Integer> oddNums = filterList(numbers, new Predicate<Integer>() {
                    @Override
                    public boolean test(Integer n) {
                        return n % 2 != 0;
                    }
                });
                System.out.println("Odd numbers (anonymous inner class): " + oddNums);
            }
        }
        ```
        *   `filterList` is a higher-order function because it takes a `Predicate<T>` (a functional interface) as a parameter, which represents a function (a condition to filter). We pass lambda expressions and an anonymous inner class instance as arguments to `filterList`.

    *   **Methods Returning Functional Interfaces or Lambdas:**
        Methods can also return functional interfaces or lambda expressions as their results. This allows you to create methods that generate or customize behavior dynamically.

        ```java
        import java.util.function.Function;

        public class FunctionReturningExample {
            // Method that returns a Function<Integer, Integer>
            public static Function<Integer, Integer> createMultiplier(int factor) {
                // Returns a lambda expression that multiplies by 'factor'
                return number -> number * factor;
            }

            public static void main(String[] args) {
                Function<Integer, Integer> multiplyBy3 = createMultiplier(3);
                Function<Integer, Integer> multiplyBy10 = createMultiplier(10);

                System.out.println("5 times 3: " + multiplyBy3.apply(5)); // Apply the function
                System.out.println("7 times 10: " + multiplyBy10.apply(7));
            }
        }
        ```
        *   `createMultiplier` is a higher-order function because it returns a `Function<Integer, Integer>` (a functional interface), which is essentially returning a function (a multiplier function).

    *   **Examples in Java Streams and other Functional APIs:**
        Java Streams API and other functional APIs (like JavaFX event handling, CompletableFuture for asynchronous programming) extensively use higher-order functions. Stream operations like `filter`, `map`, `sorted`, `forEach`, `reduce` all are higher-order functions because they take functional interfaces (lambdas or method references) as arguments to specify the operations to be performed on the stream elements.

**Exception Handling in Methods**

*   **`throws` clause in Method Declaration:**
    The `throws` clause is used in a method declaration to indicate that the method might throw one or more checked exceptions during its execution. It's part of the method signature.

    ```java
    public void myMethod() throws IOException, SQLException {
        // Method body that might throw IOException or SQLException
        // ...
    }
    ```
    *   If a method might throw checked exceptions (exceptions that must be either handled or declared to be thrown), you must either:
        1.  Handle the exception using a `try-catch` block within the method itself.
        2.  Declare the exception in the method's `throws` clause, indicating that the method will propagate the exception to its caller.

    *   **Checked vs. Unchecked Exceptions in Method Context:**
        *   **Checked Exceptions:** (e.g., `IOException`, `SQLException`, `FileNotFoundException`) - These are exceptions that the compiler *forces* you to handle or declare. If a method can throw a checked exception, you must either catch it in a `try-catch` block or declare it in the `throws` clause. This is to ensure that potential exception scenarios are considered and handled.
        *   **Unchecked Exceptions:** (e.g., `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`, `RuntimeException` and its subclasses) - These are also called runtime exceptions. The compiler does *not* force you to handle or declare unchecked exceptions. They typically indicate programming errors or exceptional conditions that are usually not recoverable and might be indicative of bugs in the code. You can still handle unchecked exceptions using `try-catch` if you choose to, but you are not required to.

*   **`try-catch` blocks within Methods:**
    You can use `try-catch` blocks within a method to handle exceptions that might occur during the method's execution.

    ```java
    public class ExceptionHandlingExample {
        public static int divide(int numerator, int denominator) {
            try {
                int result = numerator / denominator; // Potential ArithmeticException (division by zero)
                System.out.println("Division successful.");
                return result;
            } catch (ArithmeticException e) {
                System.err.println("Error: Division by zero occurred.");
                return 0; // Or throw a more meaningful exception, or handle it in another way
            }
        }

        public static void readFile(String filePath) {
            try {
                // Code to read from a file that might throw FileNotFoundException or IOException
                java.io.File file = new java.io.File(filePath);
                java.io.FileReader fileReader = new java.io.FileReader(file);
                java.io.BufferedReader bufferedReader = new java.io.BufferedReader(fileReader);
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    System.out.println(line);
                }
                bufferedReader.close();
                fileReader.close();
            } catch (java.io.FileNotFoundException e) {
                System.err.println("Error: File not found: " + filePath);
            } catch (java.io.IOException e) {
                System.err.println("Error: I/O exception while reading file: " + e.getMessage());
            }
        }

        public static void main(String[] args) {
            int result1 = divide(10, 2);
            System.out.println("Result of 10/2: " + result1);

            int result2 = divide(10, 0); // This will cause an ArithmeticException, which is caught
            System.out.println("Result of 10/0: " + result2);

            readFile("nonexistent_file.txt"); // This might throw FileNotFoundException
            readFile("example.txt"); // Assuming example.txt exists and is readable
        }
    }
    ```
    *   In `divide`, we use a `try-catch` block to handle `ArithmeticException` that can occur if `denominator` is zero.
    *   In `readFile`, we use `try-catch` to handle `FileNotFoundException` and `IOException` that might occur during file operations.
    *   If an exception occurs within the `try` block, the execution immediately jumps to the corresponding `catch` block that handles the exception type. If no exception occurs, the `catch` block is skipped.

*   **Custom Exceptions and Methods:**
    You can create your own custom exception classes by extending `Exception` (for checked exceptions) or `RuntimeException` (for unchecked exceptions). You can then throw these custom exceptions from your methods to signal specific error conditions that are meaningful in your application domain.

    ```java
    // Custom checked exception
    class InsufficientFundsException extends Exception {
        public InsufficientFundsException(String message) {
            super(message);
        }
    }

    public class CustomExceptionExample {
        public static void withdraw(double amount, double balance) throws InsufficientFundsException {
            if (amount > balance) {
                throw new InsufficientFundsException("Insufficient balance to withdraw " + amount + ". Current balance: " + balance);
            }
            System.out.println("Withdrawal successful. Remaining balance: " + (balance - amount));
        }

        public static void main(String[] args) {
            double accountBalance = 100.0;
            try {
                withdraw(50.0, accountBalance); // OK withdrawal
                withdraw(150.0, accountBalance); // Attempt to withdraw more than balance, throws exception
            } catch (InsufficientFundsException e) {
                System.err.println("Exception caught: " + e.getMessage());
            }
        }
    }
    ```
    *   `InsufficientFundsException` is a custom checked exception.
    *   `withdraw` method declares that it `throws InsufficientFundsException`. It throws this exception if the withdrawal amount exceeds the balance.
    *   The `main` method uses a `try-catch` block to handle the `InsufficientFundsException`.

*   **`finally` block in Methods:**
    The `finally` block is an optional block that can follow `try` and `catch` blocks. Code in the `finally` block is *always* executed, regardless of whether an exception occurred in the `try` block or not, and regardless of whether a `catch` block was executed or not. It's executed even if there's a `return` statement in the `try` or `catch` block.

    *   **Purpose of the `finally` block:**
        The main purpose of the `finally` block is to ensure that cleanup code (like closing resources, releasing connections, etc.) is always executed, regardless of the outcome of the `try` block.

    *   **Execution of `finally` regardless of Exceptions:**
        The `finally` block is guaranteed to execute in almost all cases, even if an exception is thrown and caught, or if an exception is thrown and not caught, or if no exception is thrown at all. The only scenarios where `finally` might not execute are in cases of catastrophic system failures (like JVM crash or system exit).

    *   **Resource Cleanup in `finally`:**
        `finally` is commonly used for resource cleanup. For example, when working with files, network connections, database connections, or other resources that need to be closed or released after use, you typically put the code to close/release these resources in a `finally` block to ensure they are always cleaned up, even if exceptions occur during the resource usage.

        **Example (`finally` block for resource cleanup):**

        ```java
        import java.io.BufferedReader;
        import java.io.FileReader;
        import java.io.IOException;

        public class FinallyBlockExample {
            public static void readFileWithFinally(String filePath) {
                BufferedReader reader = null; // Initialize reader outside try block for finally access
                try {
                    reader = new BufferedReader(new FileReader(filePath));
                    String line;
                    while ((line = reader.readLine()) != null) {
                        System.out.println(line);
                    }
                    // No explicit reader.close() here, it's done in finally
                } catch (IOException e) {
                    System.err.println("Error reading file: " + e.getMessage());
                } finally {
                    // Cleanup code in finally block - always executed
                    if (reader != null) {
                        try {
                            reader.close(); // Close the BufferedReader
                            System.out.println("BufferedReader closed in finally block.");
                        } catch (IOException closeException) {
                            System.err.println("Error closing BufferedReader: " + closeException.getMessage());
                        }
                    }
                }
            }

            public static void main(String[] args) {
                readFileWithFinally("example.txt"); // Assuming example.txt exists
                readFileWithFinally("nonexistent_file.txt"); // File not found, exception will be caught, finally will still execute
            }
        }
        ```
        *   We initialize `BufferedReader reader = null;` outside the `try` block so that it's accessible in the `finally` block.
        *   In the `finally` block, we check if `reader` is not `null` (meaning it was successfully initialized in the `try` block). If so, we try to close it using `reader.close()`. This ensures that the `BufferedReader` is closed even if exceptions occur during file reading or if the method exits early.
        *   The `reader.close()` call itself might also throw an `IOException`, so we put it in another `try-catch` block inside `finally` to handle potential closing errors gracefully.

**Generic Methods**

*   **Introduction to Generic Methods:**
    Generic methods are methods that are parameterized by type. They allow you to write methods that can work with different data types without being specific to a particular type. Generics enhance type safety and code reusability.

*   **Type Parameters in Method Declarations:**
    To make a method generic, you declare type parameters in the method's declaration. Type parameters are placed inside angle brackets `<>` before the return type of the method. They are usually represented by single uppercase letters, like `T`, `E`, `K`, `V`, etc.

    ```java
    public static <T> void printArray(T[] array) { // <T> is the type parameter declaration
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    ```
    *   `<T>` is the type parameter declaration. It indicates that `T` is a type parameter that will be replaced with an actual type when the method is called.
    *   `T[] array` means the method accepts an array of type `T`.
    *   The return type is `void`.

*   **Benefits of Generic Methods (Type Safety, Reusability):**
    *   **Type Safety:** Generics provide compile-time type safety. When you use a generic method, the compiler checks if the types of arguments you are passing are compatible with the type parameters. This helps catch type-related errors at compile time rather than at runtime, making your code more robust.
    *   **Code Reusability:** Generic methods are highly reusable. You write a single generic method that can work with different types of data. You don't need to write separate methods for each type, reducing code duplication and improving maintainability.

*   **Bounded Type Parameters in Generic Methods:**
    You can add bounds to type parameters to restrict the types that can be used as type arguments. Bounded type parameters are specified using the `extends` keyword.

    *   **Upper Bound:** Limits the type parameter to be a subtype of a specific class or interface.

        ```java
        // Method that works with lists of Number or its subclasses (e.g., Integer, Double)
        public static <T extends Number> double sumOfList(List<T> list) {
            double sum = 0;
            for (T num : list) {
                sum += num.doubleValue(); // Number class has doubleValue() method
            }
            return sum;
        }
        ```
        `T extends Number` means that `T` must be either `Number` itself or a subclass of `Number` (like `Integer`, `Double`, `Float`, etc.). You cannot pass a `List` of `String` to this method because `String` is not a subtype of `Number`.

    *   **Multiple Bounds:** You can specify multiple bounds using `&` for interfaces.

        ```java
        interface Printable {
            void print();
        }

        interface Sortable {
            void sort();
        }

        // Method that works with types that implement both Printable and Sortable interfaces
        public static <T extends Printable & Sortable> void processObject(T obj) {
            obj.print();
            obj.sort();
        }
        ```
        `T extends Printable & Sortable` means that `T` must implement both `Printable` and `Sortable` interfaces.

*   **Type Erasure in Generic Methods:**
    Type erasure is a fundamental aspect of how Java implements generics. It's the process by which the Java compiler removes generic type information at compile time.

    *   **Explanation of Type Erasure at Runtime:**
        At runtime, generic type information is not available. When you compile Java code with generics, the compiler performs type checking to ensure type safety. After type checking, the compiler erases all generic type information. This means that at runtime, a generic type like `List<String>` is treated simply as `List` (raw type), without any information about the element type `String`.

    *   **Implications and Limitations of Type Erasure:**
        *   **No Runtime Type Information:** You cannot determine the actual type argument of a generic type at runtime using reflection in a straightforward way for type parameters. For example, if you have a `List<?> list`, you cannot directly find out if it was originally declared as `List<String>` or `List<Integer>` at runtime.
        *   **Restrictions on Type-Specific Operations:** Due to type erasure, you cannot perform operations that depend on runtime type information of type parameters within a generic method in a type-safe way. For instance, you cannot create new instances of type parameters directly using `new T()`, because the actual type of `T` is not known at runtime.
        *   **Casting:** When you retrieve elements from a generic collection, you might need to cast them to their expected type because the compiler only knows that they are of the raw type (e.g., `Object` for `List`). However, with generics, these casts are generally type-safe and checked at compile time.
        *   **Arrays of Generic Types:** Creating arrays of parameterized types (e.g., `new List<String>[10]`) is not directly allowed in Java due to type erasure and array covariance issues. You can work around this using techniques like using raw types or creating arrays of raw types and casting.

        Despite these limitations, type erasure is a design choice made in Java to ensure backward compatibility with older versions of Java that did not have generics. It allows Java code with generics to run on older JVMs. Type erasure has implications for how generics are used and what is possible at runtime, but it also enables Java to maintain compatibility and benefit from generics' type safety and reusability features.

**Interface Methods (Specific to Interfaces)**

*   **Default Methods in Interfaces:**
    Default methods, introduced in Java 8, are interface methods that have a default implementation provided in the interface itself. They are declared using the `default` keyword.

    *   **Definition and Purpose of Default Methods:**
        Before Java 8, interfaces could only declare abstract methods (methods without implementation). Default methods were added to allow interfaces to evolve over time without breaking backward compatibility with existing implementations. If you add a new abstract method to an interface, all classes that implement that interface would need to be modified to provide an implementation for the new method. Default methods provide a way to add new functionality to interfaces without forcing all implementing classes to change.

    *   **Implementing Default Methods:**
        Classes that implement an interface with default methods inherit the default implementation. They can choose to either:
        1.  **Use the default implementation:** If a class doesn't provide its own implementation for a default method, it will use the default implementation provided in the interface.
        2.  **Override the default implementation:** A class can provide its own implementation for a default method, effectively overriding the default behavior. This is similar to method overriding in inheritance.

        ```java
        interface MyInterface {
            void abstractMethod(); // Abstract method

            default void defaultMethod() { // Default method with implementation
                System.out.println("Default implementation of defaultMethod in MyInterface.");
            }
        }

        class MyClass implements MyInterface {
            @Override
            public void abstractMethod() {
                System.out.println("Implementation of abstractMethod in MyClass.");
            }

            // Not overriding defaultMethod, so it will use the default implementation from MyInterface
        }

        class AnotherClass implements MyInterface {
            @Override
            public void abstractMethod() {
                System.out.println("Implementation of abstractMethod in AnotherClass.");
            }

            @Override
            public void defaultMethod() { // Overriding the default method with a custom implementation
                System.out.println("Custom implementation of defaultMethod in AnotherClass.");
            }
        }

        public class DefaultMethodExample {
            public static void main(String[] args) {
                MyClass obj1 = new MyClass();
                obj1.abstractMethod();
                obj1.defaultMethod(); // Uses default implementation

                AnotherClass obj2 = new AnotherClass();
                obj2.abstractMethod();
                obj2.defaultMethod(); // Uses custom overridden implementation
            }
        }
        ```

    *   **Diamond Problem and Default Methods:**
        The "diamond problem" is an issue that can arise in multiple inheritance scenarios. In Java, a class can implement multiple interfaces. If two interfaces have default methods with the same signature, and a class implements both interfaces, there could be a conflict: which default method implementation should be used?

        Java resolves the diamond problem for default methods using these rules:
        1.  **Class Implementation Wins:** If a class inherits a default method from an interface and also has a method with the same signature from its superclass (or a superclass further up in the hierarchy), the class's method (or the superclass method) implementation takes precedence over the default method from the interface. Class inheritance always wins over interface default methods.
        2.  **Interface Prioritization:** If a class implements multiple interfaces that both define default methods with the same signature, the class must explicitly override the default method and provide its own implementation to resolve the conflict. If it doesn't, it will result in a compile-time error.

        ```java
        interface InterfaceA {
            default void commonMethod() {
                System.out.println("Default method from InterfaceA");
            }
        }

        interface InterfaceB {
            default void commonMethod() {
                System.out.println("Default method from InterfaceB");
            }
        }

        class MyClassImpl implements InterfaceA, InterfaceB {
            @Override
            public void commonMethod() { // Must override to resolve conflict
                System.out.println("Custom implementation in MyClassImpl");
                InterfaceA.super.commonMethod(); // Can call InterfaceA's default method
                InterfaceB.super.commonMethod(); // Can call InterfaceB's default method
            }
        }

        public class DiamondProblemExample {
            public static void main(String[] args) {
                MyClassImpl obj = new MyClassImpl();
                obj.commonMethod();
            }
        }
        ```
        In `MyClassImpl`, we have to override `commonMethod` because both `InterfaceA` and `InterfaceB` have a default method with the same signature. Inside the overridden method, we can choose to call the default method from either interface using `InterfaceA.super.commonMethod()` or `InterfaceB.super.commonMethod()`, or provide entirely custom logic.

*   **Static Methods in Interfaces:**
    Static methods in interfaces, also introduced in Java 8, are static methods that are defined directly within an interface. They are called using the interface name, just like static methods in classes are called using the class name.

    *   **Definition and Purpose of Static Methods in Interfaces:**
        Static methods in interfaces are utility methods that are related to the interface itself. They are not meant to be implemented or overridden by classes that implement the interface. They are more like helper methods or factory methods associated with the interface.

    *   **Calling Static Methods of Interfaces:**
        You call static methods of an interface using the interface name and the dot operator, `InterfaceName.staticMethodName()`.

        ```java
        interface MathOperations {
            static int add(int a, int b) {
                return a + b;
            }

            static double squareRoot(double num) {
                if (num < 0) {
                    throw new IllegalArgumentException("Cannot calculate square root of a negative number.");
                }
                return Math.sqrt(num);
            }
        }

        public class InterfaceStaticMethodExample {
            public static void main(String[] args) {
                int sum = MathOperations.add(10, 5); // Calling static method using interface name
                System.out.println("Sum: " + sum);

                double sqrtValue = MathOperations.squareRoot(25.0); // Calling another static method
                System.out.println("Square root of 25: " + sqrtValue);

                // MathOperations operations = new MathOperations(); // Error: Cannot instantiate interface
                // operations.add(1, 2); // Error: Cannot call static method on an instance (even if you could instantiate)
            }
        }
        ```
        *   `MathOperations.add()` and `MathOperations.squareRoot()` are static methods of the `MathOperations` interface. You call them using `MathOperations.methodName()`.
        *   You cannot create instances of interfaces, so you cannot call static methods on an interface instance.

*   **Private Methods in Interfaces (Java 9+):**
    Private methods in interfaces, introduced in Java 9, are private methods that can be defined within an interface. They are meant for internal use within the interface itself, primarily to share code between default methods or other private methods in the same interface.

    *   **Definition and Purpose of Private Interface Methods:**
        Private interface methods cannot be accessed from outside the interface (neither from implementing classes nor from other interfaces). Their purpose is to help in code reuse and organization within the interface itself. They are particularly useful when you have multiple default methods in an interface that share some common logic. You can extract this common logic into a private method and have the default methods call the private method.

    *   **Code Reusability within Interfaces using Private Methods:**

        ```java
        interface StringProcessor {
            default String processString(String input) {
                validateInput(input); // Call private validation method
                String processed = transformString(input); // Call private transformation method
                return formatOutput(processed); // Call private formatting method
            }

            default String processAnotherString(String input) {
                validateInput(input); // Reuse validation logic
                String processed = reverseString(input); // Different transformation
                return formatOutput(processed); // Reuse formatting logic
            }

            private void validateInput(String input) { // Private method for validation
                if (input == null || input.isEmpty()) {
                    throw new IllegalArgumentException("Input string cannot be null or empty.");
                }
                // More validation logic...
            }

            private String transformString(String input) { // Private method for transformation
                return input.toUpperCase();
            }

            private String reverseString(String input) { // Another private method for transformation
                return new StringBuilder(input).reverse().toString();
            }

            private String formatOutput(String processedString) { // Private method for output formatting
                return "Processed String: [" + processedString + "]";
            }
        }

        class StringProcessorImpl implements StringProcessor {
            // No need to implement or override the default methods from StringProcessor interface
        }

        public class PrivateInterfaceMethodExample {
            public static void main(String[] args) {
                StringProcessor processor = new StringProcessorImpl();
                String result1 = processor.processString("hello");
                System.out.println(result1);

                String result2 = processor.processAnotherString("world");
                System.out.println(result2);

                // processor.validateInput("test"); // Error: Cannot access private method from outside interface
            }
        }
        ```
        *   `validateInput`, `transformString`, `reverseString`, and `formatOutput` are private methods in the `StringProcessor` interface.
        *   `processString` and `processAnotherString` are default methods that reuse the logic in these private methods.
        *   Private interface methods help in keeping the implementation details of interface methods encapsulated within the interface itself and promote code reuse within the interface.

**Method Modifiers (Beyond Access Modifiers) - Consolidated**

*   **`static` Modifier:**
    *   **Purpose:** Creates a class method (static method) instead of an instance method. Static methods belong to the class itself, not to any specific object.
    *   **Usage:** Called using the class name (e.g., `ClassName.staticMethod()`). Cannot directly access instance variables (non-static fields) of the class without an object instance. Can be called without creating an object of the class.
    *   **Example:** `Math.sqrt()`, `Integer.parseInt()`, static factory methods.

*   **`final` Modifier:**
    *   **Purpose:** Prevents method overriding in subclasses. Once a method is declared `final`, no subclass can override it.
    *   **Usage:** Declared using `final` keyword before the return type in method declaration.
    *   **Example:** Methods in immutable classes are often `final`.

*   **`abstract` Modifier:**
    *   **Purpose:** Declares an abstract method. An abstract method has no implementation (no method body). It must be implemented by concrete subclasses (if in an abstract class) or by classes that implement the interface (if in an interface).
    *   **Usage:** Declared using `abstract` keyword. Abstract methods can only exist in abstract classes or interfaces. Abstract classes cannot be instantiated.
    *   **Example:** Abstract methods in abstract classes like `Shape.getArea()` or in interfaces like `Drawable.draw()`.

*   **`synchronized` Modifier:**
    *   **Purpose:** Used for thread synchronization. When a method is declared `synchronized`, it means that only one thread can execute this method on a given object instance at a time. It provides mutual exclusion, preventing race conditions in multi-threaded environments.
    *   **Usage:** Declared using `synchronized` keyword in method declaration.
    *   **Example:** Methods that update shared mutable state in a multi-threaded application.

*   **`native` Modifier:**
    *   **Purpose:** Indicates that the method's implementation is written in a native language (like C or C++) and is loaded via JNI (Java Native Interface).
    *   **Usage:** Declared using `native` keyword. Method declaration has no body (ends with a semicolon `;`). The actual implementation is in a native library.
    *   **Example:** Methods in `java.lang.System`, `java.lang.Thread` that interact with the operating system or hardware.

*   **`strictfp` Modifier:**
    *   **Purpose:** Ensures strict floating-point calculations according to IEEE 754 standard across all platforms. It affects floating-point operations within the method.
    *   **Usage:** Declared using `strictfp` keyword. Can be applied to a method or a class.
    *   **Example:** In scientific or financial applications where precise floating-point calculations are critical.

*   **`transient` Modifier (in context of methods - less common, but technically possible if methods were part of serialized state - usually less relevant):**
    *   **Purpose:** The `transient` modifier is primarily used for instance variables (fields). It indicates that a field should not be serialized when an object is serialized. In the context of methods, it's *very rarely* used and technically doesn't have a direct meaning in terms of method behavior. If you were to somehow serialize a method (which is not a standard Java serialization concept for methods themselves), then `transient` might theoretically be used to indicate that the method's state (if methods could have state that's serialized) should not be persisted. However, methods are generally not part of the object's serialized state in typical Java serialization. It's more relevant for fields that represent the state of an object.

*   **`volatile` Modifier (in context of methods - less common, but related to thread safety if methods access volatile variables):**
    *   **Purpose:** The `volatile` modifier is primarily used for instance variables (fields). It ensures that reads and writes to a `volatile` variable are always performed from/to main memory, not from CPU caches, making sure that all threads see the most up-to-date value. In the context of methods, `volatile` is *not* applied to methods directly. However, if a method accesses a `volatile` variable, the method's behavior can be affected by whether the variable is `volatile` or not, especially in multi-threaded programs. Methods that read or write `volatile` variables need to be aware of the memory visibility guarantees provided by `volatile` for thread safety.

**Method Design Principles and Best Practices**

*   **Method Naming Conventions:**
    *   **Descriptive Names:** Choose names that clearly and concisely describe what the method does. Method names should be verbs or verb phrases (e.g., `calculateSum()`, `getUserName()`, `isValidInput()`).
    *   **Camel Case:** Use camelCase naming convention (start with lowercase, and capitalize the first letter of each subsequent word, e.g., `calculateTotalAmount`).
    *   **Consistency:** Be consistent in naming style throughout your codebase.
    *   **Avoid Abbreviations (unless widely understood):** Use full words for clarity (e.g., `getUserAddress` instead of `getUsrAddr`).
    *   **Boolean Methods:** For methods that return a boolean value (true/false), use names that read like a question or a predicate (e.g., `isValid()`, `isEven()`, `hasPermission()`).

*   **Method Length:**
    *   **Keep Methods Short and Focused:** Aim for methods that are short and perform a single, well-defined task. Shorter methods are generally easier to understand, test, and maintain.
    *   **Rule of Thumb (Subjective):**  A method longer than 20-30 lines of code might be a candidate for refactoring. This is not a strict rule, but a guideline. If a method is getting too long, consider breaking it down into smaller, more manageable methods.
    *   **Extract Methods:** If you find a block of code within a method that performs a distinct task, consider extracting it into a separate, well-named method. This improves code organization and reusability.

*   **Method Comments and Documentation (Javadoc):**
    *   **Javadoc Comments:** Use Javadoc comments (`/** ... */`) to document your methods. Javadoc comments can be processed to generate API documentation in HTML format.
    *   **`@param` tag:** Document each parameter using `@param parameterName description`.
    *   **`@return` tag:** Document the return value using `@return description`.
    *   **`@throws` tag:** Document any checked exceptions that the method might throw using `@throws ExceptionType description`.
    *   **Method Purpose:** Clearly describe what the method does, its purpose, and any important considerations or preconditions.
    *   **Example:**

        ```java
        /**
         * Calculates the factorial of a non-negative integer.
         *
         * @param n The non-negative integer for which to calculate the factorial.
         * @return The factorial of n, or -1 if n is negative (invalid input).
         * @throws IllegalArgumentException if n is negative.
         */
        public static long factorial(int n) throws IllegalArgumentException {
            if (n < 0) {
                throw new IllegalArgumentException("Input must be a non-negative integer.");
            }
            if (n == 0 || n == 1) {
                return 1;
            }
            long result = 1;
            for (int i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }
        ```

*   **Single Responsibility Principle for Methods:**
    *   **SRP for Methods:** Each method should have one and only one responsibility. It should perform a single, well-defined task. Avoid methods that do too many things.
    *   **Focus and Cohesion:** A method with a single responsibility is easier to understand, test, reuse, and modify. It also promotes high cohesion (methods within a class are related and work together towards a common purpose).
    *   **Example (Violating SRP - Method doing too much):**

        ```java
        // Method that violates SRP - does multiple things: validates, processes, logs
        public void processOrder(Order order) {
            if (order == null || order.getItems().isEmpty()) {
                System.err.println("Error: Invalid order."); // Logging/Error reporting
                return;
            }
            // ... Order processing logic ...
            System.out.println("Order processed successfully."); // Logging
        }

        // Better approach - separate responsibilities into different methods
        public boolean isValidOrder(Order order) { // Responsibility: Validation
            return order != null && !order.getItems().isEmpty();
        }

        public void processOrderItems(Order order) { // Responsibility: Processing items
            // ... Order item processing logic ...
        }

        public void logOrderProcessingSuccess(Order order) { // Responsibility: Logging success
            System.out.println("Order processed successfully.");
        }

        public void logOrderProcessingError(Order order, String errorMessage) { // Responsibility: Logging error
            System.err.println("Error processing order: " + errorMessage);
        }

        public void handleOrder(Order order) { // Orchestrating method
            if (!isValidOrder(order)) {
                logOrderProcessingError(order, "Invalid order data.");
                return;
            }
            processOrderItems(order);
            logOrderProcessingSuccess(order);
        }
        ```
        In the "better approach," responsibilities are separated into methods like `isValidOrder`, `processOrderItems`, `logOrderProcessingSuccess`, `logOrderProcessingError`. The `handleOrder` method acts as an orchestrator, calling these smaller, focused methods.

*   **Code Reusability and Modularity through Methods:**
    *   **Design for Reusability:** Write methods that are general-purpose and can be reused in different parts of your program or in other programs. Avoid methods that are too specific or tightly coupled to a particular context.
    *   **Parameterization:** Use parameters to make methods more flexible and reusable. Parameters allow you to pass different input values to a method, making it adaptable to various situations.
    *   **Modularity:** Methods are the building blocks of modular programming. By breaking down your program into well-defined methods, you create modules of code that can be developed, tested, and maintained independently. This enhances code organization and reduces complexity.

*   **Method Design Principles (Cohesion and Coupling):**
    *   **High Cohesion in Methods:** Aim for high cohesion within methods and classes. Cohesion refers to how well the elements within a module (like a method or a class) belong together and work towards a common purpose. A method with high cohesion performs a single, well-defined task. A class with high cohesion has methods and fields that are closely related and contribute to the class's overall responsibility.
    *   **Loose Coupling between Methods and Classes:** Strive for loose coupling between methods and classes. Coupling refers to the degree of interdependence between modules. Loose coupling means that modules are relatively independent and changes in one module have minimal impact on other modules. Methods should ideally interact with other methods and classes through well-defined interfaces and contracts, rather than being tightly intertwined with their internal implementations.

*   **Defensive Programming in Methods:**
    Defensive programming is a technique of writing code that anticipates potential errors and problems and takes steps to handle them gracefully or prevent them from causing harm.

    *   **Input Validation and Parameter Checking:**
        *   **Validate Inputs:** Always validate method inputs (parameters) to ensure they are within expected ranges, are not null (if null is not allowed), and meet any other preconditions before proceeding with the method's core logic.
        *   **Null Checks:** Check for null parameters if null is not a valid input.
        *   **Range Checks:** Check if numeric parameters are within valid ranges (e.g., positive, non-negative, within a certain limit).
        *   **Type Checks:** If necessary, verify the types of parameters (though Java's static typing helps with this).
        *   **Example:**

            ```java
            public static int calculateSquareRoot(int number) {
                if (number < 0) {
                    throw new IllegalArgumentException("Input number must be non-negative."); // Input validation
                }
                return (int) Math.sqrt(number);
            }
            ```

    *   **Handling Null Inputs and Edge Cases:**
        *   **Null Input Handling:** Decide how your method should behave when it receives null inputs. Should it throw an exception, return a default value, or handle null gracefully? Document your choice.
        *   **Edge Cases:** Consider edge cases and boundary conditions for your method's inputs and logic. Test your method with edge cases (e.g., empty strings, zero values, very large numbers, empty collections) to ensure it behaves correctly in these situations.

